{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport findNearestDatumX from './findNearestDatumX';\nimport findNearestDatumY from './findNearestDatumY';\n/**\n * This is a wrapper around findNearestDatumX/Y for BarGroup, accounting for a\n * Bar's group scale offset (which findNearestDatum does not).\n */\n\nexport default function findNearestGroupDatum(nearestDatumArgs, groupScale, horizontal) {\n  var dataKey = nearestDatumArgs.dataKey,\n      xAccessor = nearestDatumArgs.xAccessor,\n      yAccessor = nearestDatumArgs.yAccessor,\n      xScale = nearestDatumArgs.xScale,\n      yScale = nearestDatumArgs.yScale,\n      point = nearestDatumArgs.point;\n  var datum = (horizontal ? findNearestDatumY : findNearestDatumX)(nearestDatumArgs);\n  if (!datum || !point) return null;\n  var barGroupOffset = groupScale(dataKey);\n  var barWidth = groupScale.step();\n\n  if (horizontal) {\n    var _groupPosition = yScale(yAccessor(datum.datum));\n\n    var _barStart = (_groupPosition != null ? _groupPosition : Infinity) + (barGroupOffset != null ? barGroupOffset : Infinity);\n\n    var _barEnd = _barStart + barWidth;\n\n    var _barMiddle = (_barStart + _barEnd) / 2;\n\n    var _cursorIsOnBar = point.y >= _barStart && point.y <= _barEnd;\n\n    return _extends({}, datum, {\n      distanceX: 0,\n      // we want all group bars to have same X distance so only Y distance matters\n      distanceY: _cursorIsOnBar ? 0 : Math.abs(point.y - _barMiddle)\n    });\n  }\n\n  var groupPosition = xScale(xAccessor(datum.datum));\n  var barStart = (groupPosition != null ? groupPosition : Infinity) + (barGroupOffset != null ? barGroupOffset : Infinity);\n  var barEnd = barStart + barWidth;\n  var barMiddle = (barStart + barEnd) / 2;\n  var cursorIsOnBar = point.x >= barStart && point.x <= barEnd;\n  return _extends({}, datum, {\n    distanceY: 0,\n    // we want all group bars to have same Y distance so only X distance matters\n    distanceX: cursorIsOnBar ? 0 : Math.abs(point.x - barMiddle)\n  });\n}","map":{"version":3,"sources":["C:/remotePackRlab-acab49ee44aa8f06acbfc147116dbc3387885161/node_modules/@visx/xychart/esm/utils/findNearestGroupDatum.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","findNearestDatumX","findNearestDatumY","findNearestGroupDatum","nearestDatumArgs","groupScale","horizontal","dataKey","xAccessor","yAccessor","xScale","yScale","point","datum","barGroupOffset","barWidth","step","_groupPosition","_barStart","Infinity","_barEnd","_barMiddle","_cursorIsOnBar","y","distanceX","distanceY","Math","abs","groupPosition","barStart","barEnd","barMiddle","cursorIsOnBar","x"],"mappings":"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","sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport findNearestDatumX from './findNearestDatumX';\nimport findNearestDatumY from './findNearestDatumY';\n/**\n * This is a wrapper around findNearestDatumX/Y for BarGroup, accounting for a\n * Bar's group scale offset (which findNearestDatum does not).\n */\n\nexport default function findNearestGroupDatum(nearestDatumArgs, groupScale, horizontal) {\n  var dataKey = nearestDatumArgs.dataKey,\n      xAccessor = nearestDatumArgs.xAccessor,\n      yAccessor = nearestDatumArgs.yAccessor,\n      xScale = nearestDatumArgs.xScale,\n      yScale = nearestDatumArgs.yScale,\n      point = nearestDatumArgs.point;\n  var datum = (horizontal ? findNearestDatumY : findNearestDatumX)(nearestDatumArgs);\n  if (!datum || !point) return null;\n  var barGroupOffset = groupScale(dataKey);\n  var barWidth = groupScale.step();\n\n  if (horizontal) {\n    var _groupPosition = yScale(yAccessor(datum.datum));\n\n    var _barStart = (_groupPosition != null ? _groupPosition : Infinity) + (barGroupOffset != null ? barGroupOffset : Infinity);\n\n    var _barEnd = _barStart + barWidth;\n\n    var _barMiddle = (_barStart + _barEnd) / 2;\n\n    var _cursorIsOnBar = point.y >= _barStart && point.y <= _barEnd;\n\n    return _extends({}, datum, {\n      distanceX: 0,\n      // we want all group bars to have same X distance so only Y distance matters\n      distanceY: _cursorIsOnBar ? 0 : Math.abs(point.y - _barMiddle)\n    });\n  }\n\n  var groupPosition = xScale(xAccessor(datum.datum));\n  var barStart = (groupPosition != null ? groupPosition : Infinity) + (barGroupOffset != null ? barGroupOffset : Infinity);\n  var barEnd = barStart + barWidth;\n  var barMiddle = (barStart + barEnd) / 2;\n  var cursorIsOnBar = point.x >= barStart && point.x <= barEnd;\n  return _extends({}, datum, {\n    distanceY: 0,\n    // we want all group bars to have same Y distance so only X distance matters\n    distanceX: cursorIsOnBar ? 0 : Math.abs(point.x - barMiddle)\n  });\n}"]},"metadata":{},"sourceType":"module"}