{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport React, { useContext, useEffect } from 'react';\nimport DataContext from '../context/DataContext';\n/**\n * An HOC that handles registering the Series's data and renders the\n * `BaseSeriesComponent`\n * - only if x and y scales are available in context, and\n * - overrides `props.data/xAccessor/yAccessor` with the values from context.\n * This is useful for avoiding nasty syntax with undefined scales when using\n * hooks, and ensures that data + scales are always matched in the case of\n * prop changes, etc.\n */\n\nexport default function withRegisteredData(BaseSeriesComponent) {\n  function WrappedComponent( // WrappedComponent props include SeriesProps with appropriate generics\n  // and any props in BaseComponentProps that are not in WithRegisteredDataProps\n  props) {\n    var dataKey = props.dataKey,\n        data = props.data,\n        xAccessor = props.xAccessor,\n        yAccessor = props.yAccessor;\n\n    var _ref = useContext(DataContext),\n        xScale = _ref.xScale,\n        yScale = _ref.yScale,\n        dataRegistry = _ref.dataRegistry;\n\n    useEffect(function () {\n      if (dataRegistry) dataRegistry.registerData({\n        key: dataKey,\n        data: data,\n        xAccessor: xAccessor,\n        yAccessor: yAccessor\n      });\n      return function () {\n        return dataRegistry == null ? void 0 : dataRegistry.unregisterData(dataKey);\n      };\n    }, [dataRegistry, dataKey, data, xAccessor, yAccessor]);\n    var registryEntry = dataRegistry == null ? void 0 : dataRegistry.get(dataKey); // if scales or data are not available in context, render nothing\n\n    if (!xScale || !yScale || !registryEntry) return null; // TODO coercion might be avoidable with variadic tuples in TS 4\n\n    var BaseComponent = BaseSeriesComponent; // otherwise pass props + over-write data/accessors\n\n    return /*#__PURE__*/React.createElement(BaseComponent, _extends({}, props, {\n      xScale: xScale,\n      yScale: yScale,\n      data: registryEntry.data,\n      xAccessor: registryEntry.xAccessor,\n      yAccessor: registryEntry.yAccessor\n    }));\n  }\n\n  return WrappedComponent;\n}","map":{"version":3,"sources":["C:/remotePackRlab-acab49ee44aa8f06acbfc147116dbc3387885161/node_modules/@visx/xychart/esm/enhancers/withRegisteredData.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","React","useContext","useEffect","DataContext","withRegisteredData","BaseSeriesComponent","WrappedComponent","props","dataKey","data","xAccessor","yAccessor","_ref","xScale","yScale","dataRegistry","registerData","unregisterData","registryEntry","get","BaseComponent","createElement"],"mappings":"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","sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React, { useContext, useEffect } from 'react';\nimport DataContext from '../context/DataContext';\n\n/**\n * An HOC that handles registering the Series's data and renders the\n * `BaseSeriesComponent`\n * - only if x and y scales are available in context, and\n * - overrides `props.data/xAccessor/yAccessor` with the values from context.\n * This is useful for avoiding nasty syntax with undefined scales when using\n * hooks, and ensures that data + scales are always matched in the case of\n * prop changes, etc.\n */\nexport default function withRegisteredData(BaseSeriesComponent) {\n  function WrappedComponent( // WrappedComponent props include SeriesProps with appropriate generics\n  // and any props in BaseComponentProps that are not in WithRegisteredDataProps\n  props) {\n    var dataKey = props.dataKey,\n        data = props.data,\n        xAccessor = props.xAccessor,\n        yAccessor = props.yAccessor;\n\n    var _ref = useContext(DataContext),\n        xScale = _ref.xScale,\n        yScale = _ref.yScale,\n        dataRegistry = _ref.dataRegistry;\n\n    useEffect(function () {\n      if (dataRegistry) dataRegistry.registerData({\n        key: dataKey,\n        data: data,\n        xAccessor: xAccessor,\n        yAccessor: yAccessor\n      });\n      return function () {\n        return dataRegistry == null ? void 0 : dataRegistry.unregisterData(dataKey);\n      };\n    }, [dataRegistry, dataKey, data, xAccessor, yAccessor]);\n    var registryEntry = dataRegistry == null ? void 0 : dataRegistry.get(dataKey); // if scales or data are not available in context, render nothing\n\n    if (!xScale || !yScale || !registryEntry) return null; // TODO coercion might be avoidable with variadic tuples in TS 4\n\n    var BaseComponent = BaseSeriesComponent; // otherwise pass props + over-write data/accessors\n\n    return /*#__PURE__*/React.createElement(BaseComponent, _extends({}, props, {\n      xScale: xScale,\n      yScale: yScale,\n      data: registryEntry.data,\n      xAccessor: registryEntry.xAccessor,\n      yAccessor: registryEntry.yAccessor\n    }));\n  }\n\n  return WrappedComponent;\n}"]},"metadata":{},"sourceType":"module"}