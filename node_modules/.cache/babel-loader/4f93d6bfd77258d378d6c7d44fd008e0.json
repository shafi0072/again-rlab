{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OrderedQueue = exports.Queue = exports.MessageQueue = void 0;\n\nconst events_1 = require(\"events\");\n\nconst message_batch_1 = require(\"./message-batch\");\n\nconst publish_error_1 = require(\"./publish-error\");\n/**\n * Queues are used to manage publishing batches of messages.\n *\n * @private\n *\n * @param {Publisher} publisher The parent publisher.\n */\n\n\nclass MessageQueue extends events_1.EventEmitter {\n  constructor(publisher) {\n    super();\n    this.publisher = publisher;\n    this.batchOptions = publisher.settings.batching;\n  }\n  /**\n   * Forces the queue to update its options from the publisher.\n   * The specific queue will need to do a bit more to pass the new\n   * values down into any MessageBatch.\n   *\n   * This is only for use by {@link Publisher}.\n   *\n   * @private\n   */\n\n\n  updateOptions() {\n    this.batchOptions = this.publisher.settings.batching;\n  }\n  /**\n   * Accepts a batch of messages and publishes them to the API.\n   *\n   * @param {object[]} messages The messages to publish.\n   * @param {PublishCallback[]} callbacks The corresponding callback functions.\n   * @param {function} [callback] Callback to be fired when publish is done.\n   */\n\n\n  _publish(messages, callbacks, callback) {\n    const {\n      topic,\n      settings\n    } = this.publisher;\n    const reqOpts = {\n      topic: topic.name,\n      messages\n    };\n\n    if (messages.length === 0) {\n      if (typeof callback === 'function') {\n        callback(null);\n      }\n\n      return;\n    }\n\n    topic.request({\n      client: 'PublisherClient',\n      method: 'publish',\n      reqOpts,\n      gaxOpts: settings.gaxOpts\n    }, (err, resp) => {\n      const messageIds = resp && resp.messageIds || [];\n      callbacks.forEach((callback, i) => callback(err, messageIds[i]));\n\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  }\n\n}\n\nexports.MessageQueue = MessageQueue;\n/**\n * Standard message queue used for publishing messages.\n *\n * @private\n * @extends MessageQueue\n *\n * @param {Publisher} publisher The publisher.\n */\n\nclass Queue extends MessageQueue {\n  constructor(publisher) {\n    super(publisher);\n    this.batch = new message_batch_1.MessageBatch(this.batchOptions);\n  } // This needs to update our existing message batch.\n\n\n  updateOptions() {\n    super.updateOptions();\n    this.batch.setOptions(this.batchOptions);\n  }\n  /**\n   * Adds a message to the queue.\n   *\n   * @param {PubsubMessage} message The message to publish.\n   * @param {PublishCallback} callback The publish callback.\n   */\n\n\n  add(message, callback) {\n    if (!this.batch.canFit(message)) {\n      this.publish();\n    }\n\n    this.batch.add(message, callback);\n\n    if (this.batch.isFull()) {\n      this.publish();\n    } else if (!this.pending) {\n      const {\n        maxMilliseconds\n      } = this.batchOptions;\n      this.pending = setTimeout(() => this.publish(), maxMilliseconds);\n    }\n  }\n  /**\n   * Cancels any pending publishes and calls _publish immediately.\n   */\n\n\n  publish(callback) {\n    const {\n      messages,\n      callbacks\n    } = this.batch;\n    this.batch = new message_batch_1.MessageBatch(this.batchOptions);\n\n    if (this.pending) {\n      clearTimeout(this.pending);\n      delete this.pending;\n    }\n\n    this._publish(messages, callbacks, callback);\n  }\n\n}\n\nexports.Queue = Queue;\n/**\n * Queue for handling ordered messages. Unlike the standard queue, this\n * ensures that batches are published one at a time and throws an exception in\n * the event that any batch fails to publish.\n *\n * @private\n * @extends MessageQueue\n *\n * @param {Publisher} publisher The publisher.\n * @param {string} key The key used to order the messages.\n */\n\nclass OrderedQueue extends MessageQueue {\n  constructor(publisher, key) {\n    super(publisher);\n    this.batches = [];\n    this.inFlight = false;\n    this.key = key;\n  } // This needs to update our existing message batches.\n\n\n  updateOptions() {\n    super.updateOptions();\n    this.batches.forEach(b => b.setOptions(this.batchOptions));\n  }\n  /**\n   * Reference to the batch we're currently filling.\n   * @returns {MessageBatch}\n   */\n\n\n  get currentBatch() {\n    if (!this.batches.length) {\n      this.batches.push(this.createBatch());\n    }\n\n    return this.batches[0];\n  }\n  /**\n   * Adds a message to a batch, creating a new batch if need be.\n   *\n   * @param {object} message The message to publish.\n   * @param {PublishCallback} callback The publish callback.\n   */\n\n\n  add(message, callback) {\n    if (this.error) {\n      callback(this.error);\n      return;\n    }\n\n    if (this.inFlight) {\n      // in the event that a batch is currently in flight, we can overfill\n      // the next batch as long as it hasn't hit the API limit\n      if (this.currentBatch.isAtMax()) {\n        this.batches.unshift(this.createBatch());\n      }\n\n      this.currentBatch.add(message, callback);\n      return;\n    }\n\n    if (!this.currentBatch.canFit(message)) {\n      this.publish();\n    }\n\n    this.currentBatch.add(message, callback); // it is possible that we triggered a publish earlier, so we'll need to\n    // check again here\n\n    if (!this.inFlight) {\n      if (this.currentBatch.isFull()) {\n        this.publish();\n      } else if (!this.pending) {\n        this.beginNextPublish();\n      }\n    }\n  }\n  /**\n   * Starts a timeout to publish any pending messages.\n   */\n\n\n  beginNextPublish() {\n    const maxMilliseconds = this.batchOptions.maxMilliseconds;\n    const timeWaiting = Date.now() - this.currentBatch.created;\n    const delay = Math.max(0, maxMilliseconds - timeWaiting);\n    this.pending = setTimeout(() => this.publish(), delay);\n  }\n  /**\n   * Creates a new {@link MessageBatch} instance.\n   *\n   * @returns {MessageBatch}\n   */\n\n\n  createBatch() {\n    return new message_batch_1.MessageBatch(this.batchOptions);\n  }\n  /**\n   * In the event of a publish failure, we need to cache the error in question\n   * and reject all pending publish calls, prompting the user to call\n   * {@link OrderedQueue#resumePublishing}.\n   *\n   * @param {Error} err The publishing error.\n   */\n\n\n  handlePublishFailure(err) {\n    this.error = new publish_error_1.PublishError(this.key, err); // reject all pending publishes\n\n    while (this.batches.length) {\n      const {\n        callbacks\n      } = this.batches.pop();\n      callbacks.forEach(callback => callback(err));\n    }\n  }\n  /**\n   * Publishes the messages. If successful it will prepare the next batch to be\n   * published immediately after. If an error occurs, it will reject all\n   * pending messages. In the event that no pending messages/batches are left,\n   * a \"drain\" event will be fired, indicating to the publisher that it is\n   * safe to delete this queue.\n   *\n   * @fires OrderedQueue#drain\n   */\n\n\n  publish(callback) {\n    const definedCallback = callback || (() => {});\n\n    this.inFlight = true;\n\n    if (this.pending) {\n      clearTimeout(this.pending);\n      delete this.pending;\n    }\n\n    const {\n      messages,\n      callbacks\n    } = this.batches.pop();\n\n    this._publish(messages, callbacks, err => {\n      this.inFlight = false;\n\n      if (err) {\n        this.handlePublishFailure(err);\n        definedCallback(err);\n      } else if (this.batches.length) {\n        this.beginNextPublish();\n      } else {\n        this.emit('drain');\n        definedCallback(null);\n      }\n    });\n  }\n  /**\n   * Tells the queue it is ok to continue publishing messages.\n   */\n\n\n  resumePublishing() {\n    delete this.error; // once this is called, we'll make this object eligible for garbage\n    // collection. by wrapping in nextTick() we'll give users an opportunity\n    // to use it again instead of deleting instantly and then creating a new\n    // instance.\n\n    process.nextTick(() => {\n      if (!this.batches.length) {\n        this.emit('drain');\n      }\n    });\n  }\n\n}\n\nexports.OrderedQueue = OrderedQueue;","map":{"version":3,"sources":["../../../src/publisher/message-queues.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OrderedQueue = exports.Queue = exports.MessageQueue = void 0;\nconst events_1 = require(\"events\");\nconst message_batch_1 = require(\"./message-batch\");\nconst publish_error_1 = require(\"./publish-error\");\n/**\n * Queues are used to manage publishing batches of messages.\n *\n * @private\n *\n * @param {Publisher} publisher The parent publisher.\n */\nclass MessageQueue extends events_1.EventEmitter {\n    constructor(publisher) {\n        super();\n        this.publisher = publisher;\n        this.batchOptions = publisher.settings.batching;\n    }\n    /**\n     * Forces the queue to update its options from the publisher.\n     * The specific queue will need to do a bit more to pass the new\n     * values down into any MessageBatch.\n     *\n     * This is only for use by {@link Publisher}.\n     *\n     * @private\n     */\n    updateOptions() {\n        this.batchOptions = this.publisher.settings.batching;\n    }\n    /**\n     * Accepts a batch of messages and publishes them to the API.\n     *\n     * @param {object[]} messages The messages to publish.\n     * @param {PublishCallback[]} callbacks The corresponding callback functions.\n     * @param {function} [callback] Callback to be fired when publish is done.\n     */\n    _publish(messages, callbacks, callback) {\n        const { topic, settings } = this.publisher;\n        const reqOpts = {\n            topic: topic.name,\n            messages,\n        };\n        if (messages.length === 0) {\n            if (typeof callback === 'function') {\n                callback(null);\n            }\n            return;\n        }\n        topic.request({\n            client: 'PublisherClient',\n            method: 'publish',\n            reqOpts,\n            gaxOpts: settings.gaxOpts,\n        }, (err, resp) => {\n            const messageIds = (resp && resp.messageIds) || [];\n            callbacks.forEach((callback, i) => callback(err, messageIds[i]));\n            if (typeof callback === 'function') {\n                callback(err);\n            }\n        });\n    }\n}\nexports.MessageQueue = MessageQueue;\n/**\n * Standard message queue used for publishing messages.\n *\n * @private\n * @extends MessageQueue\n *\n * @param {Publisher} publisher The publisher.\n */\nclass Queue extends MessageQueue {\n    constructor(publisher) {\n        super(publisher);\n        this.batch = new message_batch_1.MessageBatch(this.batchOptions);\n    }\n    // This needs to update our existing message batch.\n    updateOptions() {\n        super.updateOptions();\n        this.batch.setOptions(this.batchOptions);\n    }\n    /**\n     * Adds a message to the queue.\n     *\n     * @param {PubsubMessage} message The message to publish.\n     * @param {PublishCallback} callback The publish callback.\n     */\n    add(message, callback) {\n        if (!this.batch.canFit(message)) {\n            this.publish();\n        }\n        this.batch.add(message, callback);\n        if (this.batch.isFull()) {\n            this.publish();\n        }\n        else if (!this.pending) {\n            const { maxMilliseconds } = this.batchOptions;\n            this.pending = setTimeout(() => this.publish(), maxMilliseconds);\n        }\n    }\n    /**\n     * Cancels any pending publishes and calls _publish immediately.\n     */\n    publish(callback) {\n        const { messages, callbacks } = this.batch;\n        this.batch = new message_batch_1.MessageBatch(this.batchOptions);\n        if (this.pending) {\n            clearTimeout(this.pending);\n            delete this.pending;\n        }\n        this._publish(messages, callbacks, callback);\n    }\n}\nexports.Queue = Queue;\n/**\n * Queue for handling ordered messages. Unlike the standard queue, this\n * ensures that batches are published one at a time and throws an exception in\n * the event that any batch fails to publish.\n *\n * @private\n * @extends MessageQueue\n *\n * @param {Publisher} publisher The publisher.\n * @param {string} key The key used to order the messages.\n */\nclass OrderedQueue extends MessageQueue {\n    constructor(publisher, key) {\n        super(publisher);\n        this.batches = [];\n        this.inFlight = false;\n        this.key = key;\n    }\n    // This needs to update our existing message batches.\n    updateOptions() {\n        super.updateOptions();\n        this.batches.forEach(b => b.setOptions(this.batchOptions));\n    }\n    /**\n     * Reference to the batch we're currently filling.\n     * @returns {MessageBatch}\n     */\n    get currentBatch() {\n        if (!this.batches.length) {\n            this.batches.push(this.createBatch());\n        }\n        return this.batches[0];\n    }\n    /**\n     * Adds a message to a batch, creating a new batch if need be.\n     *\n     * @param {object} message The message to publish.\n     * @param {PublishCallback} callback The publish callback.\n     */\n    add(message, callback) {\n        if (this.error) {\n            callback(this.error);\n            return;\n        }\n        if (this.inFlight) {\n            // in the event that a batch is currently in flight, we can overfill\n            // the next batch as long as it hasn't hit the API limit\n            if (this.currentBatch.isAtMax()) {\n                this.batches.unshift(this.createBatch());\n            }\n            this.currentBatch.add(message, callback);\n            return;\n        }\n        if (!this.currentBatch.canFit(message)) {\n            this.publish();\n        }\n        this.currentBatch.add(message, callback);\n        // it is possible that we triggered a publish earlier, so we'll need to\n        // check again here\n        if (!this.inFlight) {\n            if (this.currentBatch.isFull()) {\n                this.publish();\n            }\n            else if (!this.pending) {\n                this.beginNextPublish();\n            }\n        }\n    }\n    /**\n     * Starts a timeout to publish any pending messages.\n     */\n    beginNextPublish() {\n        const maxMilliseconds = this.batchOptions.maxMilliseconds;\n        const timeWaiting = Date.now() - this.currentBatch.created;\n        const delay = Math.max(0, maxMilliseconds - timeWaiting);\n        this.pending = setTimeout(() => this.publish(), delay);\n    }\n    /**\n     * Creates a new {@link MessageBatch} instance.\n     *\n     * @returns {MessageBatch}\n     */\n    createBatch() {\n        return new message_batch_1.MessageBatch(this.batchOptions);\n    }\n    /**\n     * In the event of a publish failure, we need to cache the error in question\n     * and reject all pending publish calls, prompting the user to call\n     * {@link OrderedQueue#resumePublishing}.\n     *\n     * @param {Error} err The publishing error.\n     */\n    handlePublishFailure(err) {\n        this.error = new publish_error_1.PublishError(this.key, err);\n        // reject all pending publishes\n        while (this.batches.length) {\n            const { callbacks } = this.batches.pop();\n            callbacks.forEach(callback => callback(err));\n        }\n    }\n    /**\n     * Publishes the messages. If successful it will prepare the next batch to be\n     * published immediately after. If an error occurs, it will reject all\n     * pending messages. In the event that no pending messages/batches are left,\n     * a \"drain\" event will be fired, indicating to the publisher that it is\n     * safe to delete this queue.\n     *\n     * @fires OrderedQueue#drain\n     */\n    publish(callback) {\n        const definedCallback = callback || (() => { });\n        this.inFlight = true;\n        if (this.pending) {\n            clearTimeout(this.pending);\n            delete this.pending;\n        }\n        const { messages, callbacks } = this.batches.pop();\n        this._publish(messages, callbacks, (err) => {\n            this.inFlight = false;\n            if (err) {\n                this.handlePublishFailure(err);\n                definedCallback(err);\n            }\n            else if (this.batches.length) {\n                this.beginNextPublish();\n            }\n            else {\n                this.emit('drain');\n                definedCallback(null);\n            }\n        });\n    }\n    /**\n     * Tells the queue it is ok to continue publishing messages.\n     */\n    resumePublishing() {\n        delete this.error;\n        // once this is called, we'll make this object eligible for garbage\n        // collection. by wrapping in nextTick() we'll give users an opportunity\n        // to use it again instead of deleting instantly and then creating a new\n        // instance.\n        process.nextTick(() => {\n            if (!this.batches.length) {\n                this.emit('drain');\n            }\n        });\n    }\n}\nexports.OrderedQueue = OrderedQueue;\n//# sourceMappingURL=message-queues.js.map"]},"metadata":{},"sourceType":"script"}