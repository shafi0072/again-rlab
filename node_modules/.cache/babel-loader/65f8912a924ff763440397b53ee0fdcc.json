{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LeaseManager = void 0;\n\nconst events_1 = require(\"events\");\n\nconst default_options_1 = require(\"./default-options\");\n/**\n * @typedef {object} FlowControlOptions\n * @property {boolean} [allowExcessMessages=true] PubSub delivers messages in\n *     batches with no way to configure the batch size. Sometimes this can be\n *     overwhelming if you only want to process a few messages at a time.\n *     Setting this option to false will make the client manage any excess\n *     messages until you're ready for them. This will prevent them from being\n *     redelivered and make the maxMessages option behave more predictably.\n * @property {number} [maxBytes=104857600] The desired amount of memory to\n *     allow message data to consume. (Default: 100MB) It's possible that this\n *     value will be exceeded, since messages are received in batches.\n * @property {number} [maxExtension=60] The maximum duration (in seconds)\n *      to extend the message deadline before redelivering.\n * @property {number} [maxMessages=1000] The desired number of messages to allow\n *     in memory before pausing the message stream. Unless allowExcessMessages\n *     is set to false, it is very likely that this value will be exceeded since\n *     any given message batch could contain a greater number of messages than\n *     the desired amount of messages.\n */\n\n/**\n * Manages a Subscribers inventory while auto-magically extending the message\n * deadlines.\n *\n * @private\n * @class\n *\n * @param {Subscriber} sub The subscriber to manage leases for.\n * @param {FlowControlOptions} options Flow control options.\n */\n\n\nclass LeaseManager extends events_1.EventEmitter {\n  constructor(sub, options = {}) {\n    super();\n    this.bytes = 0;\n    this._isLeasing = false;\n    this._messages = new Set();\n    this._pending = [];\n    this._subscriber = sub;\n    this.setOptions(options);\n  }\n  /**\n   * @type {number}\n   * @private\n   */\n\n\n  get pending() {\n    return this._pending.length;\n  }\n  /**\n   * @type {number}\n   * @private\n   */\n\n\n  get size() {\n    return this._messages.size;\n  }\n  /**\n   * Adds a message to the inventory, kicking off the deadline extender if it\n   * isn't already running.\n   *\n   * @param {Message} message The message.\n   * @private\n   */\n\n\n  add(message) {\n    const {\n      allowExcessMessages\n    } = this._options;\n    const wasFull = this.isFull();\n\n    this._messages.add(message);\n\n    this.bytes += message.length;\n\n    if (allowExcessMessages || !wasFull) {\n      this._dispense(message);\n    } else {\n      this._pending.push(message);\n    }\n\n    if (!this._isLeasing) {\n      this._isLeasing = true;\n\n      this._scheduleExtension();\n    }\n\n    if (!wasFull && this.isFull()) {\n      this.emit('full');\n    }\n  }\n  /**\n   * Removes ALL messages from inventory.\n   * @private\n   */\n\n\n  clear() {\n    const wasFull = this.isFull();\n    this._pending = [];\n\n    this._messages.clear();\n\n    this.bytes = 0;\n\n    if (wasFull) {\n      process.nextTick(() => this.emit('free'));\n    }\n\n    this._cancelExtension();\n  }\n  /**\n   * Indicates if we're at or over capacity.\n   *\n   * @returns {boolean}\n   * @private\n   */\n\n\n  isFull() {\n    const {\n      maxBytes,\n      maxMessages\n    } = this._options;\n    return this.size >= maxMessages || this.bytes >= maxBytes;\n  }\n  /**\n   * Removes a message from the inventory. Stopping the deadline extender if no\n   * messages are left over.\n   *\n   * @fires LeaseManager#free\n   *\n   * @param {Message} message The message to remove.\n   * @private\n   */\n\n\n  remove(message) {\n    if (!this._messages.has(message)) {\n      return;\n    }\n\n    const wasFull = this.isFull();\n\n    this._messages.delete(message);\n\n    this.bytes -= message.length;\n\n    if (wasFull && !this.isFull()) {\n      process.nextTick(() => this.emit('free'));\n    } else if (this._pending.includes(message)) {\n      const index = this._pending.indexOf(message);\n\n      this._pending.splice(index, 1);\n    } else if (this.pending > 0) {\n      this._dispense(this._pending.shift());\n    }\n\n    if (this.size === 0 && this._isLeasing) {\n      this._cancelExtension();\n    }\n  }\n  /**\n   * Sets options for the LeaseManager.\n   *\n   * @param {FlowControlOptions} [options] The options.\n   * @private\n   */\n\n\n  setOptions(options) {\n    const defaults = {\n      allowExcessMessages: true,\n      maxBytes: default_options_1.defaultOptions.subscription.maxOutstandingBytes,\n      maxExtension: default_options_1.defaultOptions.subscription.maxExtensionMinutes,\n      maxMessages: default_options_1.defaultOptions.subscription.maxOutstandingMessages\n    };\n    this._options = Object.assign(defaults, options);\n  }\n  /**\n   * Stops extending message deadlines.\n   *\n   * @private\n   */\n\n\n  _cancelExtension() {\n    this._isLeasing = false;\n\n    if (this._timer) {\n      clearTimeout(this._timer);\n      delete this._timer;\n    }\n  }\n  /**\n   * Emits the message. Emitting messages is very slow, so to avoid it acting\n   * as a bottleneck, we're wrapping it in nextTick.\n   *\n   * @private\n   *\n   * @fires Subscriber#message\n   *\n   * @param {Message} message The message to emit.\n   */\n\n\n  _dispense(message) {\n    if (this._subscriber.isOpen) {\n      process.nextTick(() => this._subscriber.emit('message', message));\n    }\n  }\n  /**\n   * Loops through inventory and extends the deadlines for any messages that\n   * have not hit the max extension option.\n   *\n   * @private\n   */\n\n\n  _extendDeadlines() {\n    const deadline = this._subscriber.ackDeadline;\n\n    for (const message of this._messages) {\n      const lifespan = (Date.now() - message.received) / 1000;\n\n      if (lifespan < this._options.maxExtension) {\n        message.modAck(deadline);\n      } else {\n        this.remove(message);\n      }\n    }\n\n    if (this._isLeasing) {\n      this._scheduleExtension();\n    }\n  }\n  /**\n   * Creates a timeout(ms) that should allow us to extend any message deadlines\n   * before they would be redelivered.\n   *\n   * @private\n   *\n   * @returns {number}\n   */\n\n\n  _getNextExtensionTimeoutMs() {\n    const jitter = Math.random();\n    const deadline = this._subscriber.ackDeadline * 1000;\n    const latency = this._subscriber.modAckLatency;\n    return (deadline * 0.9 - latency) * jitter;\n  }\n  /**\n   * Schedules an deadline extension for all messages.\n   *\n   * @private\n   */\n\n\n  _scheduleExtension() {\n    const timeout = this._getNextExtensionTimeoutMs();\n\n    this._timer = setTimeout(() => this._extendDeadlines(), timeout);\n  }\n\n}\n\nexports.LeaseManager = LeaseManager;","map":{"version":3,"sources":["../../src/lease-manager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LeaseManager = void 0;\nconst events_1 = require(\"events\");\nconst default_options_1 = require(\"./default-options\");\n/**\n * @typedef {object} FlowControlOptions\n * @property {boolean} [allowExcessMessages=true] PubSub delivers messages in\n *     batches with no way to configure the batch size. Sometimes this can be\n *     overwhelming if you only want to process a few messages at a time.\n *     Setting this option to false will make the client manage any excess\n *     messages until you're ready for them. This will prevent them from being\n *     redelivered and make the maxMessages option behave more predictably.\n * @property {number} [maxBytes=104857600] The desired amount of memory to\n *     allow message data to consume. (Default: 100MB) It's possible that this\n *     value will be exceeded, since messages are received in batches.\n * @property {number} [maxExtension=60] The maximum duration (in seconds)\n *      to extend the message deadline before redelivering.\n * @property {number} [maxMessages=1000] The desired number of messages to allow\n *     in memory before pausing the message stream. Unless allowExcessMessages\n *     is set to false, it is very likely that this value will be exceeded since\n *     any given message batch could contain a greater number of messages than\n *     the desired amount of messages.\n */\n/**\n * Manages a Subscribers inventory while auto-magically extending the message\n * deadlines.\n *\n * @private\n * @class\n *\n * @param {Subscriber} sub The subscriber to manage leases for.\n * @param {FlowControlOptions} options Flow control options.\n */\nclass LeaseManager extends events_1.EventEmitter {\n    constructor(sub, options = {}) {\n        super();\n        this.bytes = 0;\n        this._isLeasing = false;\n        this._messages = new Set();\n        this._pending = [];\n        this._subscriber = sub;\n        this.setOptions(options);\n    }\n    /**\n     * @type {number}\n     * @private\n     */\n    get pending() {\n        return this._pending.length;\n    }\n    /**\n     * @type {number}\n     * @private\n     */\n    get size() {\n        return this._messages.size;\n    }\n    /**\n     * Adds a message to the inventory, kicking off the deadline extender if it\n     * isn't already running.\n     *\n     * @param {Message} message The message.\n     * @private\n     */\n    add(message) {\n        const { allowExcessMessages } = this._options;\n        const wasFull = this.isFull();\n        this._messages.add(message);\n        this.bytes += message.length;\n        if (allowExcessMessages || !wasFull) {\n            this._dispense(message);\n        }\n        else {\n            this._pending.push(message);\n        }\n        if (!this._isLeasing) {\n            this._isLeasing = true;\n            this._scheduleExtension();\n        }\n        if (!wasFull && this.isFull()) {\n            this.emit('full');\n        }\n    }\n    /**\n     * Removes ALL messages from inventory.\n     * @private\n     */\n    clear() {\n        const wasFull = this.isFull();\n        this._pending = [];\n        this._messages.clear();\n        this.bytes = 0;\n        if (wasFull) {\n            process.nextTick(() => this.emit('free'));\n        }\n        this._cancelExtension();\n    }\n    /**\n     * Indicates if we're at or over capacity.\n     *\n     * @returns {boolean}\n     * @private\n     */\n    isFull() {\n        const { maxBytes, maxMessages } = this._options;\n        return this.size >= maxMessages || this.bytes >= maxBytes;\n    }\n    /**\n     * Removes a message from the inventory. Stopping the deadline extender if no\n     * messages are left over.\n     *\n     * @fires LeaseManager#free\n     *\n     * @param {Message} message The message to remove.\n     * @private\n     */\n    remove(message) {\n        if (!this._messages.has(message)) {\n            return;\n        }\n        const wasFull = this.isFull();\n        this._messages.delete(message);\n        this.bytes -= message.length;\n        if (wasFull && !this.isFull()) {\n            process.nextTick(() => this.emit('free'));\n        }\n        else if (this._pending.includes(message)) {\n            const index = this._pending.indexOf(message);\n            this._pending.splice(index, 1);\n        }\n        else if (this.pending > 0) {\n            this._dispense(this._pending.shift());\n        }\n        if (this.size === 0 && this._isLeasing) {\n            this._cancelExtension();\n        }\n    }\n    /**\n     * Sets options for the LeaseManager.\n     *\n     * @param {FlowControlOptions} [options] The options.\n     * @private\n     */\n    setOptions(options) {\n        const defaults = {\n            allowExcessMessages: true,\n            maxBytes: default_options_1.defaultOptions.subscription.maxOutstandingBytes,\n            maxExtension: default_options_1.defaultOptions.subscription.maxExtensionMinutes,\n            maxMessages: default_options_1.defaultOptions.subscription.maxOutstandingMessages,\n        };\n        this._options = Object.assign(defaults, options);\n    }\n    /**\n     * Stops extending message deadlines.\n     *\n     * @private\n     */\n    _cancelExtension() {\n        this._isLeasing = false;\n        if (this._timer) {\n            clearTimeout(this._timer);\n            delete this._timer;\n        }\n    }\n    /**\n     * Emits the message. Emitting messages is very slow, so to avoid it acting\n     * as a bottleneck, we're wrapping it in nextTick.\n     *\n     * @private\n     *\n     * @fires Subscriber#message\n     *\n     * @param {Message} message The message to emit.\n     */\n    _dispense(message) {\n        if (this._subscriber.isOpen) {\n            process.nextTick(() => this._subscriber.emit('message', message));\n        }\n    }\n    /**\n     * Loops through inventory and extends the deadlines for any messages that\n     * have not hit the max extension option.\n     *\n     * @private\n     */\n    _extendDeadlines() {\n        const deadline = this._subscriber.ackDeadline;\n        for (const message of this._messages) {\n            const lifespan = (Date.now() - message.received) / 1000;\n            if (lifespan < this._options.maxExtension) {\n                message.modAck(deadline);\n            }\n            else {\n                this.remove(message);\n            }\n        }\n        if (this._isLeasing) {\n            this._scheduleExtension();\n        }\n    }\n    /**\n     * Creates a timeout(ms) that should allow us to extend any message deadlines\n     * before they would be redelivered.\n     *\n     * @private\n     *\n     * @returns {number}\n     */\n    _getNextExtensionTimeoutMs() {\n        const jitter = Math.random();\n        const deadline = this._subscriber.ackDeadline * 1000;\n        const latency = this._subscriber.modAckLatency;\n        return (deadline * 0.9 - latency) * jitter;\n    }\n    /**\n     * Schedules an deadline extension for all messages.\n     *\n     * @private\n     */\n    _scheduleExtension() {\n        const timeout = this._getNextExtensionTimeoutMs();\n        this._timer = setTimeout(() => this._extendDeadlines(), timeout);\n    }\n}\nexports.LeaseManager = LeaseManager;\n//# sourceMappingURL=lease-manager.js.map"]},"metadata":{},"sourceType":"script"}