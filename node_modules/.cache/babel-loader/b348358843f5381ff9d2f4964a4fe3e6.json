{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Publisher = exports.BATCH_LIMITS = void 0;\n\nconst promisify_1 = require(\"@google-cloud/promisify\");\n\nconst extend = require(\"extend\");\n\nconst semantic_conventions_1 = require(\"@opentelemetry/semantic-conventions\");\n\nconst api_1 = require(\"@opentelemetry/api\");\n\nconst message_queues_1 = require(\"./message-queues\");\n\nconst default_options_1 = require(\"../default-options\");\n\nconst opentelemetry_tracing_1 = require(\"../opentelemetry-tracing\");\n/**\n * @typedef PublishOptions\n * @property {BatchPublishOptions} [batching] The maximum number of bytes to\n *     buffer before sending a payload.\n * @property {object} [gaxOpts] Request configuration options, outlined\n *     {@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html|here.}\n * @property {boolean} [messageOrdering] If true, messages published with the\n * same order key in Message will be delivered to the subscribers in the order in which they\n *  are received by the Pub/Sub system. Otherwise, they may be delivered in\n * any order.\n */\n\n\nexports.BATCH_LIMITS = {\n  maxBytes: Math.pow(1024, 2) * 9,\n  maxMessages: 1000\n};\n/**\n * A Publisher object allows you to publish messages to a specific topic.\n *\n * @private\n * @class\n *\n * @see [Topics: publish API Documentation]{@link https://cloud.google.com/pubsub/docs/reference/rest/v1/projects.topics/publish}\n *\n * @param {Topic} topic The topic associated with this publisher.\n * @param {PublishOptions} [options] Configuration object.\n */\n\nclass Publisher {\n  constructor(topic, options) {\n    this.setOptions(options);\n    this.topic = topic;\n    this.queue = new message_queues_1.Queue(this);\n    this.orderedQueues = new Map();\n  }\n  /**\n   * Immediately sends all remaining queued data. This is mostly useful\n   * if you are planning to call close() on the PubSub object that holds\n   * the server connections.\n   *\n   * @private\n   *\n   * @param {EmptyCallback} [callback] Callback function.\n   * @returns {Promise<EmptyResponse>}\n   */\n\n\n  flush(callback) {\n    const definedCallback = callback ? callback : () => {};\n    const publishes = [promisify_1.promisify(this.queue.publish).bind(this.queue)()];\n    Array.from(this.orderedQueues.values()).forEach(q => publishes.push(promisify_1.promisify(q.publish).bind(q)()));\n    const allPublishes = Promise.all(publishes);\n    allPublishes.then(() => {\n      definedCallback(null);\n    }).catch(definedCallback);\n  }\n  /**\n   * Publish the provided message.\n   *\n   * @deprecated use {@link Publisher#publishMessage} instead.\n   *\n   * @private\n   * @see Publisher#publishMessage\n   *\n   * @param {buffer} data The message data. This must come in the form of a\n   *     Buffer object.\n   * @param {object.<string, string>} [attributes] Attributes for this message.\n   * @param {PublishCallback} [callback] Callback function.\n   * @returns {Promise<PublishResponse>}\n   */\n\n\n  publish(data, attrsOrCb, callback) {\n    const attributes = typeof attrsOrCb === 'object' ? attrsOrCb : {};\n    callback = typeof attrsOrCb === 'function' ? attrsOrCb : callback;\n    return this.publishMessage({\n      data,\n      attributes\n    }, callback);\n  }\n  /**\n   * Publish the provided message.\n   *\n   * @private\n   *\n   * @throws {TypeError} If data is not a Buffer object.\n   * @throws {TypeError} If any value in `attributes` object is not a string.\n   *\n   * @param {PubsubMessage} [message] Options for this message.\n   * @param {PublishCallback} [callback] Callback function.\n   */\n\n\n  publishMessage(message, callback) {\n    const {\n      data,\n      attributes = {}\n    } = message;\n\n    if (!(data instanceof Buffer)) {\n      throw new TypeError('Data must be in the form of a Buffer.');\n    }\n\n    for (const key of Object.keys(attributes)) {\n      const value = attributes[key];\n\n      if (typeof value !== 'string') {\n        throw new TypeError(`All attributes must be in the form of a string.\n\\nInvalid value of type \"${typeof value}\" provided for \"${key}\".`);\n      }\n    }\n\n    const span = this.constructSpan(message);\n\n    if (!message.orderingKey) {\n      this.queue.add(message, callback);\n\n      if (span) {\n        span.end();\n      }\n\n      return;\n    }\n\n    const key = message.orderingKey;\n\n    if (!this.orderedQueues.has(key)) {\n      const queue = new message_queues_1.OrderedQueue(this, key);\n      this.orderedQueues.set(key, queue);\n      queue.once('drain', () => this.orderedQueues.delete(key));\n    }\n\n    const queue = this.orderedQueues.get(key);\n    queue.add(message, callback);\n\n    if (span) {\n      span.end();\n    }\n  }\n  /**\n   * Indicates to the publisher that it is safe to continue publishing for the\n   * supplied ordering key.\n   *\n   * @private\n   *\n   * @param {string} key The ordering key to continue publishing for.\n   */\n\n\n  resumePublishing(key) {\n    const queue = this.orderedQueues.get(key);\n\n    if (queue) {\n      queue.resumePublishing();\n    }\n  }\n  /**\n   * Returns the set of default options used for {@link Publisher}. The\n   * returned value is a copy, and editing it will have no effect elsehwere.\n   *\n   * This is a non-static method to make it easier to access/stub.\n   *\n   * @private\n   *\n   * @returns {PublishOptions}\n   */\n\n\n  getOptionDefaults() {\n    // Return a unique copy to avoid shenanigans.\n    const defaults = {\n      batching: {\n        maxBytes: default_options_1.defaultOptions.publish.maxOutstandingBytes,\n        maxMessages: default_options_1.defaultOptions.publish.maxOutstandingMessages,\n        maxMilliseconds: default_options_1.defaultOptions.publish.maxDelayMillis\n      },\n      messageOrdering: false,\n      gaxOpts: {\n        isBundling: false\n      },\n      enableOpenTelemetryTracing: false\n    };\n    return defaults;\n  }\n  /**\n   * Sets the Publisher options.\n   *\n   * @private\n   *\n   * @param {PublishOptions} options The publisher options.\n   */\n\n\n  setOptions(options = {}) {\n    const defaults = this.getOptionDefaults();\n    const {\n      batching,\n      gaxOpts,\n      messageOrdering,\n      enableOpenTelemetryTracing\n    } = extend(true, defaults, options);\n    this.settings = {\n      batching: {\n        maxBytes: Math.min(batching.maxBytes, exports.BATCH_LIMITS.maxBytes),\n        maxMessages: Math.min(batching.maxMessages, exports.BATCH_LIMITS.maxMessages),\n        maxMilliseconds: batching.maxMilliseconds\n      },\n      gaxOpts,\n      messageOrdering,\n      enableOpenTelemetryTracing\n    }; // We also need to let all of our queues know that they need to update their options.\n    // Note that these might be undefined, because setOptions() is called in the constructor.\n\n    if (this.queue) {\n      this.queue.updateOptions();\n    }\n\n    if (this.orderedQueues) {\n      for (const q of this.orderedQueues.values()) {\n        q.updateOptions();\n      }\n    }\n  }\n  /**\n   * Constructs an OpenTelemetry span\n   *\n   * @private\n   *\n   * @param {PubsubMessage} message The message to create a span for\n   */\n\n\n  constructSpan(message) {\n    var _a;\n\n    if (!this.settings.enableOpenTelemetryTracing) {\n      return undefined;\n    }\n\n    const spanAttributes = {\n      // Add Opentelemetry semantic convention attributes to the span, based on:\n      // https://github.com/open-telemetry/opentelemetry-specification/blob/v1.1.0/specification/trace/semantic_conventions/messaging.md\n      [semantic_conventions_1.SemanticAttributes.MESSAGING_TEMP_DESTINATION]: false,\n      [semantic_conventions_1.SemanticAttributes.MESSAGING_SYSTEM]: 'pubsub',\n      [semantic_conventions_1.SemanticAttributes.MESSAGING_OPERATION]: 'send',\n      [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION]: this.topic.name,\n      [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION_KIND]: 'topic',\n      [semantic_conventions_1.SemanticAttributes.MESSAGING_MESSAGE_ID]: message.messageId,\n      [semantic_conventions_1.SemanticAttributes.MESSAGING_PROTOCOL]: 'pubsub',\n      [semantic_conventions_1.SemanticAttributes.MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES]: (_a = message.data) === null || _a === void 0 ? void 0 : _a.length,\n      'messaging.pubsub.ordering_key': message.orderingKey\n    };\n    const span = opentelemetry_tracing_1.createSpan(`${this.topic.name} send`, api_1.SpanKind.PRODUCER, spanAttributes); // If the span's context is valid we should pass the span context special attribute\n\n    if (api_1.isSpanContextValid(span.spanContext())) {\n      if (message.attributes && message.attributes['googclient_OpenTelemetrySpanContext']) {\n        console.warn('googclient_OpenTelemetrySpanContext key set as message attribute, but will be overridden.');\n      }\n\n      if (!message.attributes) {\n        message.attributes = {};\n      }\n\n      message.attributes['googclient_OpenTelemetrySpanContext'] = JSON.stringify(span.spanContext());\n    }\n\n    return span;\n  }\n\n}\n\nexports.Publisher = Publisher;\npromisify_1.promisifyAll(Publisher, {\n  singular: true,\n  exclude: ['publish', 'setOptions', 'constructSpan', 'getOptionDefaults']\n});","map":{"version":3,"sources":["../../../src/publisher/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Publisher = exports.BATCH_LIMITS = void 0;\nconst promisify_1 = require(\"@google-cloud/promisify\");\nconst extend = require(\"extend\");\nconst semantic_conventions_1 = require(\"@opentelemetry/semantic-conventions\");\nconst api_1 = require(\"@opentelemetry/api\");\nconst message_queues_1 = require(\"./message-queues\");\nconst default_options_1 = require(\"../default-options\");\nconst opentelemetry_tracing_1 = require(\"../opentelemetry-tracing\");\n/**\n * @typedef PublishOptions\n * @property {BatchPublishOptions} [batching] The maximum number of bytes to\n *     buffer before sending a payload.\n * @property {object} [gaxOpts] Request configuration options, outlined\n *     {@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html|here.}\n * @property {boolean} [messageOrdering] If true, messages published with the\n * same order key in Message will be delivered to the subscribers in the order in which they\n *  are received by the Pub/Sub system. Otherwise, they may be delivered in\n * any order.\n */\nexports.BATCH_LIMITS = {\n    maxBytes: Math.pow(1024, 2) * 9,\n    maxMessages: 1000,\n};\n/**\n * A Publisher object allows you to publish messages to a specific topic.\n *\n * @private\n * @class\n *\n * @see [Topics: publish API Documentation]{@link https://cloud.google.com/pubsub/docs/reference/rest/v1/projects.topics/publish}\n *\n * @param {Topic} topic The topic associated with this publisher.\n * @param {PublishOptions} [options] Configuration object.\n */\nclass Publisher {\n    constructor(topic, options) {\n        this.setOptions(options);\n        this.topic = topic;\n        this.queue = new message_queues_1.Queue(this);\n        this.orderedQueues = new Map();\n    }\n    /**\n     * Immediately sends all remaining queued data. This is mostly useful\n     * if you are planning to call close() on the PubSub object that holds\n     * the server connections.\n     *\n     * @private\n     *\n     * @param {EmptyCallback} [callback] Callback function.\n     * @returns {Promise<EmptyResponse>}\n     */\n    flush(callback) {\n        const definedCallback = callback ? callback : () => { };\n        const publishes = [promisify_1.promisify(this.queue.publish).bind(this.queue)()];\n        Array.from(this.orderedQueues.values()).forEach(q => publishes.push(promisify_1.promisify(q.publish).bind(q)()));\n        const allPublishes = Promise.all(publishes);\n        allPublishes\n            .then(() => {\n            definedCallback(null);\n        })\n            .catch(definedCallback);\n    }\n    /**\n     * Publish the provided message.\n     *\n     * @deprecated use {@link Publisher#publishMessage} instead.\n     *\n     * @private\n     * @see Publisher#publishMessage\n     *\n     * @param {buffer} data The message data. This must come in the form of a\n     *     Buffer object.\n     * @param {object.<string, string>} [attributes] Attributes for this message.\n     * @param {PublishCallback} [callback] Callback function.\n     * @returns {Promise<PublishResponse>}\n     */\n    publish(data, attrsOrCb, callback) {\n        const attributes = typeof attrsOrCb === 'object' ? attrsOrCb : {};\n        callback = typeof attrsOrCb === 'function' ? attrsOrCb : callback;\n        return this.publishMessage({ data, attributes }, callback);\n    }\n    /**\n     * Publish the provided message.\n     *\n     * @private\n     *\n     * @throws {TypeError} If data is not a Buffer object.\n     * @throws {TypeError} If any value in `attributes` object is not a string.\n     *\n     * @param {PubsubMessage} [message] Options for this message.\n     * @param {PublishCallback} [callback] Callback function.\n     */\n    publishMessage(message, callback) {\n        const { data, attributes = {} } = message;\n        if (!(data instanceof Buffer)) {\n            throw new TypeError('Data must be in the form of a Buffer.');\n        }\n        for (const key of Object.keys(attributes)) {\n            const value = attributes[key];\n            if (typeof value !== 'string') {\n                throw new TypeError(`All attributes must be in the form of a string.\n\\nInvalid value of type \"${typeof value}\" provided for \"${key}\".`);\n            }\n        }\n        const span = this.constructSpan(message);\n        if (!message.orderingKey) {\n            this.queue.add(message, callback);\n            if (span) {\n                span.end();\n            }\n            return;\n        }\n        const key = message.orderingKey;\n        if (!this.orderedQueues.has(key)) {\n            const queue = new message_queues_1.OrderedQueue(this, key);\n            this.orderedQueues.set(key, queue);\n            queue.once('drain', () => this.orderedQueues.delete(key));\n        }\n        const queue = this.orderedQueues.get(key);\n        queue.add(message, callback);\n        if (span) {\n            span.end();\n        }\n    }\n    /**\n     * Indicates to the publisher that it is safe to continue publishing for the\n     * supplied ordering key.\n     *\n     * @private\n     *\n     * @param {string} key The ordering key to continue publishing for.\n     */\n    resumePublishing(key) {\n        const queue = this.orderedQueues.get(key);\n        if (queue) {\n            queue.resumePublishing();\n        }\n    }\n    /**\n     * Returns the set of default options used for {@link Publisher}. The\n     * returned value is a copy, and editing it will have no effect elsehwere.\n     *\n     * This is a non-static method to make it easier to access/stub.\n     *\n     * @private\n     *\n     * @returns {PublishOptions}\n     */\n    getOptionDefaults() {\n        // Return a unique copy to avoid shenanigans.\n        const defaults = {\n            batching: {\n                maxBytes: default_options_1.defaultOptions.publish.maxOutstandingBytes,\n                maxMessages: default_options_1.defaultOptions.publish.maxOutstandingMessages,\n                maxMilliseconds: default_options_1.defaultOptions.publish.maxDelayMillis,\n            },\n            messageOrdering: false,\n            gaxOpts: {\n                isBundling: false,\n            },\n            enableOpenTelemetryTracing: false,\n        };\n        return defaults;\n    }\n    /**\n     * Sets the Publisher options.\n     *\n     * @private\n     *\n     * @param {PublishOptions} options The publisher options.\n     */\n    setOptions(options = {}) {\n        const defaults = this.getOptionDefaults();\n        const { batching, gaxOpts, messageOrdering, enableOpenTelemetryTracing } = extend(true, defaults, options);\n        this.settings = {\n            batching: {\n                maxBytes: Math.min(batching.maxBytes, exports.BATCH_LIMITS.maxBytes),\n                maxMessages: Math.min(batching.maxMessages, exports.BATCH_LIMITS.maxMessages),\n                maxMilliseconds: batching.maxMilliseconds,\n            },\n            gaxOpts,\n            messageOrdering,\n            enableOpenTelemetryTracing,\n        };\n        // We also need to let all of our queues know that they need to update their options.\n        // Note that these might be undefined, because setOptions() is called in the constructor.\n        if (this.queue) {\n            this.queue.updateOptions();\n        }\n        if (this.orderedQueues) {\n            for (const q of this.orderedQueues.values()) {\n                q.updateOptions();\n            }\n        }\n    }\n    /**\n     * Constructs an OpenTelemetry span\n     *\n     * @private\n     *\n     * @param {PubsubMessage} message The message to create a span for\n     */\n    constructSpan(message) {\n        var _a;\n        if (!this.settings.enableOpenTelemetryTracing) {\n            return undefined;\n        }\n        const spanAttributes = {\n            // Add Opentelemetry semantic convention attributes to the span, based on:\n            // https://github.com/open-telemetry/opentelemetry-specification/blob/v1.1.0/specification/trace/semantic_conventions/messaging.md\n            [semantic_conventions_1.SemanticAttributes.MESSAGING_TEMP_DESTINATION]: false,\n            [semantic_conventions_1.SemanticAttributes.MESSAGING_SYSTEM]: 'pubsub',\n            [semantic_conventions_1.SemanticAttributes.MESSAGING_OPERATION]: 'send',\n            [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION]: this.topic.name,\n            [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION_KIND]: 'topic',\n            [semantic_conventions_1.SemanticAttributes.MESSAGING_MESSAGE_ID]: message.messageId,\n            [semantic_conventions_1.SemanticAttributes.MESSAGING_PROTOCOL]: 'pubsub',\n            [semantic_conventions_1.SemanticAttributes.MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES]: (_a = message.data) === null || _a === void 0 ? void 0 : _a.length,\n            'messaging.pubsub.ordering_key': message.orderingKey,\n        };\n        const span = opentelemetry_tracing_1.createSpan(`${this.topic.name} send`, api_1.SpanKind.PRODUCER, spanAttributes);\n        // If the span's context is valid we should pass the span context special attribute\n        if (api_1.isSpanContextValid(span.spanContext())) {\n            if (message.attributes &&\n                message.attributes['googclient_OpenTelemetrySpanContext']) {\n                console.warn('googclient_OpenTelemetrySpanContext key set as message attribute, but will be overridden.');\n            }\n            if (!message.attributes) {\n                message.attributes = {};\n            }\n            message.attributes['googclient_OpenTelemetrySpanContext'] =\n                JSON.stringify(span.spanContext());\n        }\n        return span;\n    }\n}\nexports.Publisher = Publisher;\npromisify_1.promisifyAll(Publisher, {\n    singular: true,\n    exclude: ['publish', 'setOptions', 'constructSpan', 'getOptionDefaults'],\n});\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}