{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ModAckQueue = exports.AckQueue = exports.MessageQueue = exports.BatchError = void 0;\n\nconst defer = require(\"p-defer\");\n/**\n * Error class used to signal a batch failure.\n *\n * @class\n *\n * @param {string} message The error message.\n * @param {ServiceError} err The grpc service error.\n */\n\n\nclass BatchError extends Error {\n  constructor(err, ackIds, rpc) {\n    super(`Failed to \"${rpc}\" for ${ackIds.length} message(s). Reason: ${process.env.DEBUG_GRPC ? err.stack : err.message}`);\n    this.ackIds = ackIds;\n    this.code = err.code;\n    this.details = err.details;\n    this.metadata = err.metadata;\n  }\n\n}\n\nexports.BatchError = BatchError;\n/**\n * @typedef {object} BatchOptions\n * @property {object} [callOptions] Request configuration option, outlined\n *     here: {@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html}.\n * @property {number} [maxMessages=3000] Maximum number of messages allowed in\n *     each batch sent.\n * @property {number} [maxMilliseconds=100] Maximum duration to wait before\n *     sending a batch. Batches can be sent earlier if the maxMessages option\n *     is met before the configured duration has passed.\n */\n\n/**\n * Class for buffering ack/modAck requests.\n *\n * @private\n * @class\n *\n * @param {Subscriber} sub The subscriber we're queueing requests for.\n * @param {BatchOptions} options Batching options.\n */\n\nclass MessageQueue {\n  constructor(sub, options = {}) {\n    this.numPendingRequests = 0;\n    this.numInFlightRequests = 0;\n    this._requests = [];\n    this._subscriber = sub;\n    this.setOptions(options);\n  }\n  /**\n   * Gets the default buffer time in ms.\n   *\n   * @returns {number}\n   * @private\n   */\n\n\n  get maxMilliseconds() {\n    return this._options.maxMilliseconds;\n  }\n  /**\n   * Adds a message to the queue.\n   *\n   * @param {Message} message The message to add.\n   * @param {number} [deadline] The deadline.\n   * @private\n   */\n\n\n  add({\n    ackId\n  }, deadline) {\n    const {\n      maxMessages,\n      maxMilliseconds\n    } = this._options;\n\n    this._requests.push([ackId, deadline]);\n\n    this.numPendingRequests += 1;\n    this.numInFlightRequests += 1;\n\n    if (this._requests.length >= maxMessages) {\n      this.flush();\n    } else if (!this._timer) {\n      this._timer = setTimeout(() => this.flush(), maxMilliseconds);\n    }\n  }\n  /**\n   * Sends a batch of messages.\n   * @private\n   */\n\n\n  async flush() {\n    if (this._timer) {\n      clearTimeout(this._timer);\n      delete this._timer;\n    }\n\n    const batch = this._requests;\n    const batchSize = batch.length;\n    const deferred = this._onFlush;\n    this._requests = [];\n    this.numPendingRequests -= batchSize;\n    delete this._onFlush;\n\n    try {\n      await this._sendBatch(batch);\n    } catch (e) {\n      this._subscriber.emit('error', e);\n    }\n\n    this.numInFlightRequests -= batchSize;\n\n    if (deferred) {\n      deferred.resolve();\n    }\n\n    if (this.numInFlightRequests <= 0 && this._onDrain) {\n      this._onDrain.resolve();\n\n      delete this._onDrain;\n    }\n  }\n  /**\n   * Returns a promise that resolves after the next flush occurs.\n   *\n   * @returns {Promise}\n   * @private\n   */\n\n\n  onFlush() {\n    if (!this._onFlush) {\n      this._onFlush = defer();\n    }\n\n    return this._onFlush.promise;\n  }\n  /**\n   * Returns a promise that resolves when all in-flight messages have settled.\n   */\n\n\n  onDrain() {\n    if (!this._onDrain) {\n      this._onDrain = defer();\n    }\n\n    return this._onDrain.promise;\n  }\n  /**\n   * Set the batching options.\n   *\n   * @param {BatchOptions} options Batching options.\n   * @private\n   */\n\n\n  setOptions(options) {\n    const defaults = {\n      maxMessages: 3000,\n      maxMilliseconds: 100\n    };\n    this._options = Object.assign(defaults, options);\n  }\n\n}\n\nexports.MessageQueue = MessageQueue;\n/**\n * Queues up Acknowledge (ack) requests.\n *\n * @private\n * @class\n */\n\nclass AckQueue extends MessageQueue {\n  /**\n   * Sends a batch of ack requests.\n   *\n   * @private\n   *\n   * @param {Array.<Array.<string|number>>} batch Array of ackIds and deadlines.\n   * @return {Promise}\n   */\n  async _sendBatch(batch) {\n    const client = await this._subscriber.getClient();\n    const ackIds = batch.map(([ackId]) => ackId);\n    const reqOpts = {\n      subscription: this._subscriber.name,\n      ackIds\n    };\n\n    try {\n      await client.acknowledge(reqOpts, this._options.callOptions);\n    } catch (e) {\n      throw new BatchError(e, ackIds, 'acknowledge');\n    }\n  }\n\n}\n\nexports.AckQueue = AckQueue;\n/**\n * Queues up ModifyAckDeadline requests and sends them out in batches.\n *\n * @private\n * @class\n */\n\nclass ModAckQueue extends MessageQueue {\n  /**\n   * Sends a batch of modAck requests. Each deadline requires its own request,\n   * so we have to group all the ackIds by deadline and send multiple requests.\n   *\n   * @private\n   *\n   * @param {Array.<Array.<string|number>>} batch Array of ackIds and deadlines.\n   * @return {Promise}\n   */\n  async _sendBatch(batch) {\n    const client = await this._subscriber.getClient();\n    const subscription = this._subscriber.name;\n    const modAckTable = batch.reduce((table, [ackId, deadline]) => {\n      if (!table[deadline]) {\n        table[deadline] = [];\n      }\n\n      table[deadline].push(ackId);\n      return table;\n    }, {});\n    const modAckRequests = Object.keys(modAckTable).map(async deadline => {\n      const ackIds = modAckTable[deadline];\n      const ackDeadlineSeconds = Number(deadline);\n      const reqOpts = {\n        subscription,\n        ackIds,\n        ackDeadlineSeconds\n      };\n\n      try {\n        await client.modifyAckDeadline(reqOpts, this._options.callOptions);\n      } catch (e) {\n        throw new BatchError(e, ackIds, 'modifyAckDeadline');\n      }\n    });\n    await Promise.all(modAckRequests);\n  }\n\n}\n\nexports.ModAckQueue = ModAckQueue;","map":{"version":3,"sources":["../../src/message-queues.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ModAckQueue = exports.AckQueue = exports.MessageQueue = exports.BatchError = void 0;\nconst defer = require(\"p-defer\");\n/**\n * Error class used to signal a batch failure.\n *\n * @class\n *\n * @param {string} message The error message.\n * @param {ServiceError} err The grpc service error.\n */\nclass BatchError extends Error {\n    constructor(err, ackIds, rpc) {\n        super(`Failed to \"${rpc}\" for ${ackIds.length} message(s). Reason: ${process.env.DEBUG_GRPC ? err.stack : err.message}`);\n        this.ackIds = ackIds;\n        this.code = err.code;\n        this.details = err.details;\n        this.metadata = err.metadata;\n    }\n}\nexports.BatchError = BatchError;\n/**\n * @typedef {object} BatchOptions\n * @property {object} [callOptions] Request configuration option, outlined\n *     here: {@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html}.\n * @property {number} [maxMessages=3000] Maximum number of messages allowed in\n *     each batch sent.\n * @property {number} [maxMilliseconds=100] Maximum duration to wait before\n *     sending a batch. Batches can be sent earlier if the maxMessages option\n *     is met before the configured duration has passed.\n */\n/**\n * Class for buffering ack/modAck requests.\n *\n * @private\n * @class\n *\n * @param {Subscriber} sub The subscriber we're queueing requests for.\n * @param {BatchOptions} options Batching options.\n */\nclass MessageQueue {\n    constructor(sub, options = {}) {\n        this.numPendingRequests = 0;\n        this.numInFlightRequests = 0;\n        this._requests = [];\n        this._subscriber = sub;\n        this.setOptions(options);\n    }\n    /**\n     * Gets the default buffer time in ms.\n     *\n     * @returns {number}\n     * @private\n     */\n    get maxMilliseconds() {\n        return this._options.maxMilliseconds;\n    }\n    /**\n     * Adds a message to the queue.\n     *\n     * @param {Message} message The message to add.\n     * @param {number} [deadline] The deadline.\n     * @private\n     */\n    add({ ackId }, deadline) {\n        const { maxMessages, maxMilliseconds } = this._options;\n        this._requests.push([ackId, deadline]);\n        this.numPendingRequests += 1;\n        this.numInFlightRequests += 1;\n        if (this._requests.length >= maxMessages) {\n            this.flush();\n        }\n        else if (!this._timer) {\n            this._timer = setTimeout(() => this.flush(), maxMilliseconds);\n        }\n    }\n    /**\n     * Sends a batch of messages.\n     * @private\n     */\n    async flush() {\n        if (this._timer) {\n            clearTimeout(this._timer);\n            delete this._timer;\n        }\n        const batch = this._requests;\n        const batchSize = batch.length;\n        const deferred = this._onFlush;\n        this._requests = [];\n        this.numPendingRequests -= batchSize;\n        delete this._onFlush;\n        try {\n            await this._sendBatch(batch);\n        }\n        catch (e) {\n            this._subscriber.emit('error', e);\n        }\n        this.numInFlightRequests -= batchSize;\n        if (deferred) {\n            deferred.resolve();\n        }\n        if (this.numInFlightRequests <= 0 && this._onDrain) {\n            this._onDrain.resolve();\n            delete this._onDrain;\n        }\n    }\n    /**\n     * Returns a promise that resolves after the next flush occurs.\n     *\n     * @returns {Promise}\n     * @private\n     */\n    onFlush() {\n        if (!this._onFlush) {\n            this._onFlush = defer();\n        }\n        return this._onFlush.promise;\n    }\n    /**\n     * Returns a promise that resolves when all in-flight messages have settled.\n     */\n    onDrain() {\n        if (!this._onDrain) {\n            this._onDrain = defer();\n        }\n        return this._onDrain.promise;\n    }\n    /**\n     * Set the batching options.\n     *\n     * @param {BatchOptions} options Batching options.\n     * @private\n     */\n    setOptions(options) {\n        const defaults = { maxMessages: 3000, maxMilliseconds: 100 };\n        this._options = Object.assign(defaults, options);\n    }\n}\nexports.MessageQueue = MessageQueue;\n/**\n * Queues up Acknowledge (ack) requests.\n *\n * @private\n * @class\n */\nclass AckQueue extends MessageQueue {\n    /**\n     * Sends a batch of ack requests.\n     *\n     * @private\n     *\n     * @param {Array.<Array.<string|number>>} batch Array of ackIds and deadlines.\n     * @return {Promise}\n     */\n    async _sendBatch(batch) {\n        const client = await this._subscriber.getClient();\n        const ackIds = batch.map(([ackId]) => ackId);\n        const reqOpts = { subscription: this._subscriber.name, ackIds };\n        try {\n            await client.acknowledge(reqOpts, this._options.callOptions);\n        }\n        catch (e) {\n            throw new BatchError(e, ackIds, 'acknowledge');\n        }\n    }\n}\nexports.AckQueue = AckQueue;\n/**\n * Queues up ModifyAckDeadline requests and sends them out in batches.\n *\n * @private\n * @class\n */\nclass ModAckQueue extends MessageQueue {\n    /**\n     * Sends a batch of modAck requests. Each deadline requires its own request,\n     * so we have to group all the ackIds by deadline and send multiple requests.\n     *\n     * @private\n     *\n     * @param {Array.<Array.<string|number>>} batch Array of ackIds and deadlines.\n     * @return {Promise}\n     */\n    async _sendBatch(batch) {\n        const client = await this._subscriber.getClient();\n        const subscription = this._subscriber.name;\n        const modAckTable = batch.reduce((table, [ackId, deadline]) => {\n            if (!table[deadline]) {\n                table[deadline] = [];\n            }\n            table[deadline].push(ackId);\n            return table;\n        }, {});\n        const modAckRequests = Object.keys(modAckTable).map(async (deadline) => {\n            const ackIds = modAckTable[deadline];\n            const ackDeadlineSeconds = Number(deadline);\n            const reqOpts = { subscription, ackIds, ackDeadlineSeconds };\n            try {\n                await client.modifyAckDeadline(reqOpts, this._options.callOptions);\n            }\n            catch (e) {\n                throw new BatchError(e, ackIds, 'modifyAckDeadline');\n            }\n        });\n        await Promise.all(modAckRequests);\n    }\n}\nexports.ModAckQueue = ModAckQueue;\n//# sourceMappingURL=message-queues.js.map"]},"metadata":{},"sourceType":"script"}