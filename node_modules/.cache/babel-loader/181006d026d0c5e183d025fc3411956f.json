{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { DiagComponentLogger } from '../diag/ComponentLogger';\nimport { createLogLevelDiagLogger } from '../diag/internal/logLevelLogger';\nimport { DiagLogLevel } from '../diag/types';\nimport { getGlobal, registerGlobal, unregisterGlobal } from '../internal/global-utils';\nvar API_NAME = 'diag';\n/**\n * Singleton object which represents the entry point to the OpenTelemetry internal\n * diagnostic API\n */\n\nvar DiagAPI =\n/** @class */\nfunction () {\n  /**\n   * Private internal constructor\n   * @private\n   */\n  function DiagAPI() {\n    function _logProxy(funcName) {\n      return function () {\n        var logger = getGlobal('diag'); // shortcut if logger not set\n\n        if (!logger) return;\n        return logger[funcName].apply(logger, // work around Function.prototype.apply types\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        arguments);\n      };\n    } // Using self local variable for minification purposes as 'this' cannot be minified\n\n\n    var self = this; // DiagAPI specific functions\n\n    self.setLogger = function (logger, logLevel) {\n      var _a, _b;\n\n      if (logLevel === void 0) {\n        logLevel = DiagLogLevel.INFO;\n      }\n\n      if (logger === self) {\n        // There isn't much we can do here.\n        // Logging to the console might break the user application.\n        // Try to log to self. If a logger was previously registered it will receive the log.\n        var err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');\n        self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);\n        return false;\n      }\n\n      var oldLogger = getGlobal('diag');\n      var newLogger = createLogLevelDiagLogger(logLevel, logger); // There already is an logger registered. We'll let it know before overwriting it.\n\n      if (oldLogger) {\n        var stack = (_b = new Error().stack) !== null && _b !== void 0 ? _b : '<failed to generate stacktrace>';\n        oldLogger.warn(\"Current logger will be overwritten from \" + stack);\n        newLogger.warn(\"Current logger will overwrite one already registered from \" + stack);\n      }\n\n      return registerGlobal('diag', newLogger, true);\n    };\n\n    self.disable = function () {\n      unregisterGlobal(API_NAME);\n    };\n\n    self.createComponentLogger = function (options) {\n      return new DiagComponentLogger(options);\n    };\n\n    self.verbose = _logProxy('verbose');\n    self.debug = _logProxy('debug');\n    self.info = _logProxy('info');\n    self.warn = _logProxy('warn');\n    self.error = _logProxy('error');\n  }\n  /** Get the singleton instance of the DiagAPI API */\n\n\n  DiagAPI.instance = function () {\n    if (!this._instance) {\n      this._instance = new DiagAPI();\n    }\n\n    return this._instance;\n  };\n\n  return DiagAPI;\n}();\n\nexport { DiagAPI };","map":{"version":3,"sources":["../../../src/api/diag.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;AAEH,SAAS,mBAAT,QAAoC,yBAApC;AACA,SAAS,wBAAT,QAAyC,iCAAzC;AACA,SAIE,YAJF,QAKO,eALP;AAMA,SACE,SADF,EAEE,cAFF,EAGE,gBAHF,QAIO,0BAJP;AAMA,IAAM,QAAQ,GAAG,MAAjB;AAEA;;;AAGG;;AACH,IAAA,OAAA;AAAA;AAAA,YAAA;AAYE;;;AAGG;AACH,WAAA,OAAA,GAAA;AACE,aAAS,SAAT,CAAmB,QAAnB,EAA6C;AAC3C,aAAO,YAAA;AACL,YAAM,MAAM,GAAG,SAAS,CAAC,MAAD,CAAxB,CADK,CAEL;;AACA,YAAI,CAAC,MAAL,EAAa;AACb,eAAO,MAAM,CAAC,QAAD,CAAN,CAAiB,KAAjB,CACL,MADK,EAEL;AACA;AACA,QAAA,SAJK,CAAP;AAMD,OAVD;AAWD,KAbH,CAeE;;;AACA,QAAM,IAAI,GAAG,IAAb,CAhBF,CAkBE;;AAEA,IAAA,IAAI,CAAC,SAAL,GAAiB,UACf,MADe,EAEf,QAFe,EAE2B;;;AAA1C,UAAA,QAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,QAAA,GAAyB,YAAY,CAAC,IAAtC;AAA0C;;AAE1C,UAAI,MAAM,KAAK,IAAf,EAAqB;AACnB;AACA;AACA;AACA,YAAM,GAAG,GAAG,IAAI,KAAJ,CACV,oIADU,CAAZ;AAGA,QAAA,IAAI,CAAC,KAAL,CAAW,CAAA,EAAA,GAAA,GAAG,CAAC,KAAJ,MAAS,IAAT,IAAS,EAAA,KAAA,KAAA,CAAT,GAAS,EAAT,GAAa,GAAG,CAAC,OAA5B;AACA,eAAO,KAAP;AACD;;AAED,UAAM,SAAS,GAAG,SAAS,CAAC,MAAD,CAA3B;AACA,UAAM,SAAS,GAAG,wBAAwB,CAAC,QAAD,EAAW,MAAX,CAA1C,CAd0C,CAe1C;;AACA,UAAI,SAAJ,EAAe;AACb,YAAM,KAAK,GAAG,CAAA,EAAA,GAAA,IAAI,KAAJ,GAAY,KAAZ,MAAiB,IAAjB,IAAiB,EAAA,KAAA,KAAA,CAAjB,GAAiB,EAAjB,GAAqB,iCAAnC;AACA,QAAA,SAAS,CAAC,IAAV,CAAe,6CAA2C,KAA1D;AACA,QAAA,SAAS,CAAC,IAAV,CACE,+DAA6D,KAD/D;AAGD;;AAED,aAAO,cAAc,CAAC,MAAD,EAAS,SAAT,EAAoB,IAApB,CAArB;AACD,KA3BD;;AA6BA,IAAA,IAAI,CAAC,OAAL,GAAe,YAAA;AACb,MAAA,gBAAgB,CAAC,QAAD,CAAhB;AACD,KAFD;;AAIA,IAAA,IAAI,CAAC,qBAAL,GAA6B,UAAC,OAAD,EAAgC;AAC3D,aAAO,IAAI,mBAAJ,CAAwB,OAAxB,CAAP;AACD,KAFD;;AAIA,IAAA,IAAI,CAAC,OAAL,GAAe,SAAS,CAAC,SAAD,CAAxB;AACA,IAAA,IAAI,CAAC,KAAL,GAAa,SAAS,CAAC,OAAD,CAAtB;AACA,IAAA,IAAI,CAAC,IAAL,GAAY,SAAS,CAAC,MAAD,CAArB;AACA,IAAA,IAAI,CAAC,IAAL,GAAY,SAAS,CAAC,MAAD,CAArB;AACA,IAAA,IAAI,CAAC,KAAL,GAAa,SAAS,CAAC,OAAD,CAAtB;AACD;AA3ED;;;AACc,EAAA,OAAA,CAAA,QAAA,GAAd,YAAA;AACE,QAAI,CAAC,KAAK,SAAV,EAAqB;AACnB,WAAK,SAAL,GAAiB,IAAI,OAAJ,EAAjB;AACD;;AAED,WAAO,KAAK,SAAZ;AACD,GANa;;AAuGhB,SAAA,OAAA;AAAC,CA3GD,EAAA","sourceRoot":"","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { DiagComponentLogger } from '../diag/ComponentLogger';\nimport { createLogLevelDiagLogger } from '../diag/internal/logLevelLogger';\nimport { DiagLogLevel, } from '../diag/types';\nimport { getGlobal, registerGlobal, unregisterGlobal, } from '../internal/global-utils';\nvar API_NAME = 'diag';\n/**\n * Singleton object which represents the entry point to the OpenTelemetry internal\n * diagnostic API\n */\nvar DiagAPI = /** @class */ (function () {\n    /**\n     * Private internal constructor\n     * @private\n     */\n    function DiagAPI() {\n        function _logProxy(funcName) {\n            return function () {\n                var logger = getGlobal('diag');\n                // shortcut if logger not set\n                if (!logger)\n                    return;\n                return logger[funcName].apply(logger, \n                // work around Function.prototype.apply types\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                arguments);\n            };\n        }\n        // Using self local variable for minification purposes as 'this' cannot be minified\n        var self = this;\n        // DiagAPI specific functions\n        self.setLogger = function (logger, logLevel) {\n            var _a, _b;\n            if (logLevel === void 0) { logLevel = DiagLogLevel.INFO; }\n            if (logger === self) {\n                // There isn't much we can do here.\n                // Logging to the console might break the user application.\n                // Try to log to self. If a logger was previously registered it will receive the log.\n                var err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');\n                self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);\n                return false;\n            }\n            var oldLogger = getGlobal('diag');\n            var newLogger = createLogLevelDiagLogger(logLevel, logger);\n            // There already is an logger registered. We'll let it know before overwriting it.\n            if (oldLogger) {\n                var stack = (_b = new Error().stack) !== null && _b !== void 0 ? _b : '<failed to generate stacktrace>';\n                oldLogger.warn(\"Current logger will be overwritten from \" + stack);\n                newLogger.warn(\"Current logger will overwrite one already registered from \" + stack);\n            }\n            return registerGlobal('diag', newLogger, true);\n        };\n        self.disable = function () {\n            unregisterGlobal(API_NAME);\n        };\n        self.createComponentLogger = function (options) {\n            return new DiagComponentLogger(options);\n        };\n        self.verbose = _logProxy('verbose');\n        self.debug = _logProxy('debug');\n        self.info = _logProxy('info');\n        self.warn = _logProxy('warn');\n        self.error = _logProxy('error');\n    }\n    /** Get the singleton instance of the DiagAPI API */\n    DiagAPI.instance = function () {\n        if (!this._instance) {\n            this._instance = new DiagAPI();\n        }\n        return this._instance;\n    };\n    return DiagAPI;\n}());\nexport { DiagAPI };\n//# sourceMappingURL=diag.js.map"]},"metadata":{},"sourceType":"module"}