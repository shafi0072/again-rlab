{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.d3 = global.d3 || {}));\n})(this, function (exports) {\n  'use strict';\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it;\n\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n\n        var F = function () {};\n\n        return {\n          s: F,\n          n: function () {\n            if (i >= o.length) return {\n              done: true\n            };\n            return {\n              done: false,\n              value: o[i++]\n            };\n          },\n          e: function (e) {\n            throw e;\n          },\n          f: F\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var normalCompletion = true,\n        didErr = false,\n        err;\n    return {\n      s: function () {\n        it = o[Symbol.iterator]();\n      },\n      n: function () {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function (e) {\n        didErr = true;\n        err = e;\n      },\n      f: function () {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n  /**\n   * de Casteljau's algorithm for drawing and splitting bezier curves.\n   * Inspired by https://pomax.github.io/bezierinfo/\n   *\n   * @param {Number[][]} points Array of [x,y] points: [start, control1, control2, ..., end]\n   *   The original segment to split.\n   * @param {Number} t Where to split the curve (value between [0, 1])\n   * @return {Object} An object { left, right } where left is the segment from 0..t and\n   *   right is the segment from t..1.\n   */\n\n\n  function decasteljau(points, t) {\n    var left = [];\n    var right = [];\n\n    function decasteljauRecurse(points, t) {\n      if (points.length === 1) {\n        left.push(points[0]);\n        right.push(points[0]);\n      } else {\n        var newPoints = Array(points.length - 1);\n\n        for (var i = 0; i < newPoints.length; i++) {\n          if (i === 0) {\n            left.push(points[0]);\n          }\n\n          if (i === newPoints.length - 1) {\n            right.push(points[i + 1]);\n          }\n\n          newPoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];\n        }\n\n        decasteljauRecurse(newPoints, t);\n      }\n    }\n\n    if (points.length) {\n      decasteljauRecurse(points, t);\n    }\n\n    return {\n      left: left,\n      right: right.reverse()\n    };\n  }\n  /**\n   * Convert segments represented as points back into a command object\n   *\n   * @param {Number[][]} points Array of [x,y] points: [start, control1, control2, ..., end]\n   *   Represents a segment\n   * @return {Object} A command object representing the segment.\n   */\n\n\n  function pointsToCommand(points) {\n    var command = {};\n\n    if (points.length === 4) {\n      command.x2 = points[2][0];\n      command.y2 = points[2][1];\n    }\n\n    if (points.length >= 3) {\n      command.x1 = points[1][0];\n      command.y1 = points[1][1];\n    }\n\n    command.x = points[points.length - 1][0];\n    command.y = points[points.length - 1][1];\n\n    if (points.length === 4) {\n      // start, control1, control2, end\n      command.type = 'C';\n    } else if (points.length === 3) {\n      // start, control, end\n      command.type = 'Q';\n    } else {\n      // start, end\n      command.type = 'L';\n    }\n\n    return command;\n  }\n  /**\n   * Runs de Casteljau's algorithm enough times to produce the desired number of segments.\n   *\n   * @param {Number[][]} points Array of [x,y] points for de Casteljau (the initial segment to split)\n   * @param {Number} segmentCount Number of segments to split the original into\n   * @return {Number[][][]} Array of segments\n   */\n\n\n  function splitCurveAsPoints(points, segmentCount) {\n    segmentCount = segmentCount || 2;\n    var segments = [];\n    var remainingCurve = points;\n    var tIncrement = 1 / segmentCount; // x-----x-----x-----x\n    // t=  0.33   0.66   1\n    // x-----o-----------x\n    // r=  0.33\n    //       x-----o-----x\n    // r=         0.5  (0.33 / (1 - 0.33))  === tIncrement / (1 - (tIncrement * (i - 1))\n    // x-----x-----x-----x----x\n    // t=  0.25   0.5   0.75  1\n    // x-----o----------------x\n    // r=  0.25\n    //       x-----o----------x\n    // r=         0.33  (0.25 / (1 - 0.25))\n    //             x-----o----x\n    // r=         0.5  (0.25 / (1 - 0.5))\n\n    for (var i = 0; i < segmentCount - 1; i++) {\n      var tRelative = tIncrement / (1 - tIncrement * i);\n      var split = decasteljau(remainingCurve, tRelative);\n      segments.push(split.left);\n      remainingCurve = split.right;\n    } // last segment is just to the end from the last point\n\n\n    segments.push(remainingCurve);\n    return segments;\n  }\n  /**\n   * Convert command objects to arrays of points, run de Casteljau's algorithm on it\n   * to split into to the desired number of segments.\n   *\n   * @param {Object} commandStart The start command object\n   * @param {Object} commandEnd The end command object\n   * @param {Number} segmentCount The number of segments to create\n   * @return {Object[]} An array of commands representing the segments in sequence\n   */\n\n\n  function splitCurve(commandStart, commandEnd, segmentCount) {\n    var points = [[commandStart.x, commandStart.y]];\n\n    if (commandEnd.x1 != null) {\n      points.push([commandEnd.x1, commandEnd.y1]);\n    }\n\n    if (commandEnd.x2 != null) {\n      points.push([commandEnd.x2, commandEnd.y2]);\n    }\n\n    points.push([commandEnd.x, commandEnd.y]);\n    return splitCurveAsPoints(points, segmentCount).map(pointsToCommand);\n  }\n\n  var commandTokenRegex = /[MLCSTQAHVZmlcstqahv]|-?[\\d.e+-]+/g;\n  /**\n   * List of params for each command type in a path `d` attribute\n   */\n\n  var typeMap = {\n    M: ['x', 'y'],\n    L: ['x', 'y'],\n    H: ['x'],\n    V: ['y'],\n    C: ['x1', 'y1', 'x2', 'y2', 'x', 'y'],\n    S: ['x2', 'y2', 'x', 'y'],\n    Q: ['x1', 'y1', 'x', 'y'],\n    T: ['x', 'y'],\n    A: ['rx', 'ry', 'xAxisRotation', 'largeArcFlag', 'sweepFlag', 'x', 'y'],\n    Z: []\n  }; // Add lower case entries too matching uppercase (e.g. 'm' == 'M')\n\n  Object.keys(typeMap).forEach(function (key) {\n    typeMap[key.toLowerCase()] = typeMap[key];\n  });\n\n  function arrayOfLength(length, value) {\n    var array = Array(length);\n\n    for (var i = 0; i < length; i++) {\n      array[i] = value;\n    }\n\n    return array;\n  }\n  /**\n   * Converts a command object to a string to be used in a `d` attribute\n   * @param {Object} command A command object\n   * @return {String} The string for the `d` attribute\n   */\n\n\n  function commandToString(command) {\n    return \"\".concat(command.type).concat(typeMap[command.type].map(function (p) {\n      return command[p];\n    }).join(','));\n  }\n  /**\n   * Converts command A to have the same type as command B.\n   *\n   * e.g., L0,5 -> C0,5,0,5,0,5\n   *\n   * Uses these rules:\n   * x1 <- x\n   * x2 <- x\n   * y1 <- y\n   * y2 <- y\n   * rx <- 0\n   * ry <- 0\n   * xAxisRotation <- read from B\n   * largeArcFlag <- read from B\n   * sweepflag <- read from B\n   *\n   * @param {Object} aCommand Command object from path `d` attribute\n   * @param {Object} bCommand Command object from path `d` attribute to match against\n   * @return {Object} aCommand converted to type of bCommand\n   */\n\n\n  function convertToSameType(aCommand, bCommand) {\n    var conversionMap = {\n      x1: 'x',\n      y1: 'y',\n      x2: 'x',\n      y2: 'y'\n    };\n    var readFromBKeys = ['xAxisRotation', 'largeArcFlag', 'sweepFlag']; // convert (but ignore M types)\n\n    if (aCommand.type !== bCommand.type && bCommand.type.toUpperCase() !== 'M') {\n      var aConverted = {};\n      Object.keys(bCommand).forEach(function (bKey) {\n        var bValue = bCommand[bKey]; // first read from the A command\n\n        var aValue = aCommand[bKey]; // if it is one of these values, read from B no matter what\n\n        if (aValue === undefined) {\n          if (readFromBKeys.includes(bKey)) {\n            aValue = bValue;\n          } else {\n            // if it wasn't in the A command, see if an equivalent was\n            if (aValue === undefined && conversionMap[bKey]) {\n              aValue = aCommand[conversionMap[bKey]];\n            } // if it doesn't have a converted value, use 0\n\n\n            if (aValue === undefined) {\n              aValue = 0;\n            }\n          }\n        }\n\n        aConverted[bKey] = aValue;\n      }); // update the type to match B\n\n      aConverted.type = bCommand.type;\n      aCommand = aConverted;\n    }\n\n    return aCommand;\n  }\n  /**\n   * Interpolate between command objects commandStart and commandEnd segmentCount times.\n   * If the types are L, Q, or C then the curves are split as per de Casteljau's algorithm.\n   * Otherwise we just copy commandStart segmentCount - 1 times, finally ending with commandEnd.\n   *\n   * @param {Object} commandStart Command object at the beginning of the segment\n   * @param {Object} commandEnd Command object at the end of the segment\n   * @param {Number} segmentCount The number of segments to split this into. If only 1\n   *   Then [commandEnd] is returned.\n   * @return {Object[]} Array of ~segmentCount command objects between commandStart and\n   *   commandEnd. (Can be segmentCount+1 objects if commandStart is type M).\n   */\n\n\n  function splitSegment(commandStart, commandEnd, segmentCount) {\n    var segments = []; // line, quadratic bezier, or cubic bezier\n\n    if (commandEnd.type === 'L' || commandEnd.type === 'Q' || commandEnd.type === 'C') {\n      segments = segments.concat(splitCurve(commandStart, commandEnd, segmentCount)); // general case - just copy the same point\n    } else {\n      var copyCommand = _extends({}, commandStart); // convert M to L\n\n\n      if (copyCommand.type === 'M') {\n        copyCommand.type = 'L';\n      }\n\n      segments = segments.concat(arrayOfLength(segmentCount - 1).map(function () {\n        return copyCommand;\n      }));\n      segments.push(commandEnd);\n    }\n\n    return segments;\n  }\n  /**\n   * Extends an array of commandsToExtend to the length of the referenceCommands by\n   * splitting segments until the number of commands match. Ensures all the actual\n   * points of commandsToExtend are in the extended array.\n   *\n   * @param {Object[]} commandsToExtend The command object array to extend\n   * @param {Object[]} referenceCommands The command object array to match in length\n   * @param {Function} excludeSegment a function that takes a start command object and\n   *   end command object and returns true if the segment should be excluded from splitting.\n   * @return {Object[]} The extended commandsToExtend array\n   */\n\n\n  function extend(commandsToExtend, referenceCommands, excludeSegment) {\n    // compute insertion points:\n    // number of segments in the path to extend\n    var numSegmentsToExtend = commandsToExtend.length - 1; // number of segments in the reference path.\n\n    var numReferenceSegments = referenceCommands.length - 1; // this value is always between [0, 1].\n\n    var segmentRatio = numSegmentsToExtend / numReferenceSegments; // create a map, mapping segments in referenceCommands to how many points\n    // should be added in that segment (should always be >= 1 since we need each\n    // point itself).\n    // 0 = segment 0-1, 1 = segment 1-2, n-1 = last vertex\n\n    var countPointsPerSegment = arrayOfLength(numReferenceSegments).reduce(function (accum, d, i) {\n      var insertIndex = Math.floor(segmentRatio * i); // handle excluding segments\n\n      if (excludeSegment && insertIndex < commandsToExtend.length - 1 && excludeSegment(commandsToExtend[insertIndex], commandsToExtend[insertIndex + 1])) {\n        // set the insertIndex to the segment that this point should be added to:\n        // round the insertIndex essentially so we split half and half on\n        // neighbouring segments. hence the segmentRatio * i < 0.5\n        var addToPriorSegment = segmentRatio * i % 1 < 0.5; // only skip segment if we already have 1 point in it (can't entirely remove a segment)\n\n        if (accum[insertIndex]) {\n          // TODO - Note this is a naive algorithm that should work for most d3-area use cases\n          // but if two adjacent segments are supposed to be skipped, this will not perform as\n          // expected. Could be updated to search for nearest segment to place the point in, but\n          // will only do that if necessary.\n          // add to the prior segment\n          if (addToPriorSegment) {\n            if (insertIndex > 0) {\n              insertIndex -= 1; // not possible to add to previous so adding to next\n            } else if (insertIndex < commandsToExtend.length - 1) {\n              insertIndex += 1;\n            } // add to next segment\n\n          } else if (insertIndex < commandsToExtend.length - 1) {\n            insertIndex += 1; // not possible to add to next so adding to previous\n          } else if (insertIndex > 0) {\n            insertIndex -= 1;\n          }\n        }\n      }\n\n      accum[insertIndex] = (accum[insertIndex] || 0) + 1;\n      return accum;\n    }, []); // extend each segment to have the correct number of points for a smooth interpolation\n\n    var extended = countPointsPerSegment.reduce(function (extended, segmentCount, i) {\n      // if last command, just add `segmentCount` number of times\n      if (i === commandsToExtend.length - 1) {\n        var lastCommandCopies = arrayOfLength(segmentCount, _extends({}, commandsToExtend[commandsToExtend.length - 1])); // convert M to L\n\n        if (lastCommandCopies[0].type === 'M') {\n          lastCommandCopies.forEach(function (d) {\n            d.type = 'L';\n          });\n        }\n\n        return extended.concat(lastCommandCopies);\n      } // otherwise, split the segment segmentCount times.\n\n\n      return extended.concat(splitSegment(commandsToExtend[i], commandsToExtend[i + 1], segmentCount));\n    }, []); // add in the very first point since splitSegment only adds in the ones after it\n\n    extended.unshift(commandsToExtend[0]);\n    return extended;\n  }\n  /**\n   * Takes a path `d` string and converts it into an array of command\n   * objects. Drops the `Z` character.\n   *\n   * @param {String|null} d A path `d` string\n   */\n\n\n  function pathCommandsFromString(d) {\n    // split into valid tokens\n    var tokens = (d || '').match(commandTokenRegex) || [];\n    var commands = [];\n    var commandArgs;\n    var command; // iterate over each token, checking if we are at a new command\n    // by presence in the typeMap\n\n    for (var i = 0; i < tokens.length; ++i) {\n      commandArgs = typeMap[tokens[i]]; // new command found:\n\n      if (commandArgs) {\n        command = {\n          type: tokens[i]\n        }; // add each of the expected args for this command:\n\n        for (var a = 0; a < commandArgs.length; ++a) {\n          command[commandArgs[a]] = +tokens[i + a + 1];\n        } // need to increment our token index appropriately since\n        // we consumed token args\n\n\n        i += commandArgs.length;\n        commands.push(command);\n      }\n    }\n\n    return commands;\n  }\n  /**\n   * Interpolate from A to B by extending A and B during interpolation to have\n   * the same number of points. This allows for a smooth transition when they\n   * have a different number of points.\n   *\n   * Ignores the `Z` command in paths unless both A and B end with it.\n   *\n   * This function works directly with arrays of command objects instead of with\n   * path `d` strings (see interpolatePath for working with `d` strings).\n   *\n   * @param {Object[]} aCommandsInput Array of path commands\n   * @param {Object[]} bCommandsInput Array of path commands\n   * @param {Function} excludeSegment a function that takes a start command object and\n   *   end command object and returns true if the segment should be excluded from splitting.\n   * @returns {Function} Interpolation function that maps t ([0, 1]) to an array of path commands.\n   */\n\n\n  function interpolatePathCommands(aCommandsInput, bCommandsInput, excludeSegment) {\n    // make a copy so we don't mess with the input arrays\n    var aCommands = aCommandsInput == null ? [] : aCommandsInput.slice();\n    var bCommands = bCommandsInput == null ? [] : bCommandsInput.slice(); // both input sets are empty, so we don't interpolate\n\n    if (!aCommands.length && !bCommands.length) {\n      return function nullInterpolator() {\n        return [];\n      };\n    } // do we add Z during interpolation? yes if both have it. (we'd expect both to have it or not)\n\n\n    var addZ = (aCommands.length === 0 || aCommands[aCommands.length - 1].type === 'Z') && (bCommands.length === 0 || bCommands[bCommands.length - 1].type === 'Z'); // we temporarily remove Z\n\n    if (aCommands.length > 0 && aCommands[aCommands.length - 1].type === 'Z') {\n      aCommands.pop();\n    }\n\n    if (bCommands.length > 0 && bCommands[bCommands.length - 1].type === 'Z') {\n      bCommands.pop();\n    } // if A is empty, treat it as if it used to contain just the first point\n    // of B. This makes it so the line extends out of from that first point.\n\n\n    if (!aCommands.length) {\n      aCommands.push(bCommands[0]); // otherwise if B is empty, treat it as if it contains the first point\n      // of A. This makes it so the line retracts into the first point.\n    } else if (!bCommands.length) {\n      bCommands.push(aCommands[0]);\n    } // extend to match equal size\n\n\n    var numPointsToExtend = Math.abs(bCommands.length - aCommands.length);\n\n    if (numPointsToExtend !== 0) {\n      // B has more points than A, so add points to A before interpolating\n      if (bCommands.length > aCommands.length) {\n        aCommands = extend(aCommands, bCommands, excludeSegment); // else if A has more points than B, add more points to B\n      } else if (bCommands.length < aCommands.length) {\n        bCommands = extend(bCommands, aCommands, excludeSegment);\n      }\n    } // commands have same length now.\n    // convert commands in A to the same type as those in B\n\n\n    aCommands = aCommands.map(function (aCommand, i) {\n      return convertToSameType(aCommand, bCommands[i]);\n    }); // create mutable interpolated command objects\n\n    var interpolatedCommands = aCommands.map(function (aCommand) {\n      return _objectSpread2({}, aCommand);\n    });\n\n    if (addZ) {\n      interpolatedCommands.push({\n        type: 'Z'\n      });\n    }\n\n    return function pathCommandInterpolator(t) {\n      // at 1 return the final value without the extensions used during interpolation\n      if (t === 1) {\n        return bCommandsInput == null ? [] : bCommandsInput;\n      } // interpolate the commands using the mutable interpolated command objs\n      // we can skip at t=0 since we copied aCommands to begin\n\n\n      if (t > 0) {\n        for (var i = 0; i < interpolatedCommands.length; ++i) {\n          // if (interpolatedCommands[i].type === 'Z') continue;\n          var aCommand = aCommands[i];\n          var bCommand = bCommands[i];\n          var interpolatedCommand = interpolatedCommands[i];\n\n          var _iterator = _createForOfIteratorHelper(typeMap[interpolatedCommand.type]),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var arg = _step.value;\n              interpolatedCommand[arg] = (1 - t) * aCommand[arg] + t * bCommand[arg]; // do not use floats for flags (#27), round to integer\n\n              if (arg === 'largeArcFlag' || arg === 'sweepFlag') {\n                interpolatedCommand[arg] = Math.round(interpolatedCommand[arg]);\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      }\n\n      return interpolatedCommands;\n    };\n  }\n  /**\n   * Interpolate from A to B by extending A and B during interpolation to have\n   * the same number of points. This allows for a smooth transition when they\n   * have a different number of points.\n   *\n   * Ignores the `Z` character in paths unless both A and B end with it.\n   *\n   * @param {String} a The `d` attribute for a path\n   * @param {String} b The `d` attribute for a path\n   * @param {Function} excludeSegment a function that takes a start command object and\n   *   end command object and returns true if the segment should be excluded from splitting.\n   * @returns {Function} Interpolation function that maps t ([0, 1]) to a path `d` string.\n   */\n\n\n  function interpolatePath(a, b, excludeSegment) {\n    var aCommands = pathCommandsFromString(a);\n    var bCommands = pathCommandsFromString(b);\n\n    if (!aCommands.length && !bCommands.length) {\n      return function nullInterpolator() {\n        return '';\n      };\n    }\n\n    var commandInterpolator = interpolatePathCommands(aCommands, bCommands, excludeSegment);\n    return function pathStringInterpolator(t) {\n      // at 1 return the final value without the extensions used during interpolation\n      if (t === 1) {\n        return b == null ? '' : b;\n      }\n\n      var interpolatedCommands = commandInterpolator(t); // convert to a string (fastest concat: https://jsperf.com/join-concat/150)\n\n      var interpolatedString = '';\n\n      var _iterator2 = _createForOfIteratorHelper(interpolatedCommands),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var interpolatedCommand = _step2.value;\n          interpolatedString += commandToString(interpolatedCommand);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return interpolatedString;\n    };\n  }\n\n  exports.interpolatePath = interpolatePath;\n  exports.interpolatePathCommands = interpolatePathCommands;\n  exports.pathCommandsFromString = pathCommandsFromString;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["C:/remotePackRlab-acab49ee44aa8f06acbfc147116dbc3387885161/node_modules/d3-interpolate-path/build/d3-interpolate-path.js"],"names":["global","factory","exports","module","define","amd","self","d3","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_extends","assign","target","i","arguments","length","source","prototype","hasOwnProperty","call","apply","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","_objectSpread2","forEach","getOwnPropertyDescriptors","defineProperties","_unsupportedIterableToArray","o","minLen","_arrayLikeToArray","n","toString","slice","constructor","name","Array","from","test","arr","len","arr2","_createForOfIteratorHelper","allowArrayLike","it","Symbol","iterator","isArray","F","s","done","e","f","TypeError","normalCompletion","didErr","err","step","next","return","decasteljau","points","t","left","right","decasteljauRecurse","newPoints","reverse","pointsToCommand","command","x2","y2","x1","y1","x","y","type","splitCurveAsPoints","segmentCount","segments","remainingCurve","tIncrement","tRelative","split","splitCurve","commandStart","commandEnd","map","commandTokenRegex","typeMap","M","L","H","V","C","S","Q","T","A","Z","toLowerCase","arrayOfLength","array","commandToString","concat","p","join","convertToSameType","aCommand","bCommand","conversionMap","readFromBKeys","toUpperCase","aConverted","bKey","bValue","aValue","undefined","includes","splitSegment","copyCommand","extend","commandsToExtend","referenceCommands","excludeSegment","numSegmentsToExtend","numReferenceSegments","segmentRatio","countPointsPerSegment","reduce","accum","d","insertIndex","Math","floor","addToPriorSegment","extended","lastCommandCopies","unshift","pathCommandsFromString","tokens","match","commands","commandArgs","a","interpolatePathCommands","aCommandsInput","bCommandsInput","aCommands","bCommands","nullInterpolator","addZ","pop","numPointsToExtend","abs","interpolatedCommands","pathCommandInterpolator","interpolatedCommand","_iterator","_step","arg","round","interpolatePath","b","commandInterpolator","pathStringInterpolator","interpolatedString","_iterator2","_step2"],"mappings":"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","sourcesContent":["(function (global, factory) {\ntypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\ntypeof define === 'function' && define.amd ? define(['exports'], factory) :\n(global = global || self, factory(global.d3 = global.d3 || {}));\n}(this, (function (exports) { 'use strict';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\n/**\n * de Casteljau's algorithm for drawing and splitting bezier curves.\n * Inspired by https://pomax.github.io/bezierinfo/\n *\n * @param {Number[][]} points Array of [x,y] points: [start, control1, control2, ..., end]\n *   The original segment to split.\n * @param {Number} t Where to split the curve (value between [0, 1])\n * @return {Object} An object { left, right } where left is the segment from 0..t and\n *   right is the segment from t..1.\n */\nfunction decasteljau(points, t) {\n  var left = [];\n  var right = [];\n\n  function decasteljauRecurse(points, t) {\n    if (points.length === 1) {\n      left.push(points[0]);\n      right.push(points[0]);\n    } else {\n      var newPoints = Array(points.length - 1);\n\n      for (var i = 0; i < newPoints.length; i++) {\n        if (i === 0) {\n          left.push(points[0]);\n        }\n\n        if (i === newPoints.length - 1) {\n          right.push(points[i + 1]);\n        }\n\n        newPoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];\n      }\n\n      decasteljauRecurse(newPoints, t);\n    }\n  }\n\n  if (points.length) {\n    decasteljauRecurse(points, t);\n  }\n\n  return {\n    left: left,\n    right: right.reverse()\n  };\n}\n/**\n * Convert segments represented as points back into a command object\n *\n * @param {Number[][]} points Array of [x,y] points: [start, control1, control2, ..., end]\n *   Represents a segment\n * @return {Object} A command object representing the segment.\n */\n\n\nfunction pointsToCommand(points) {\n  var command = {};\n\n  if (points.length === 4) {\n    command.x2 = points[2][0];\n    command.y2 = points[2][1];\n  }\n\n  if (points.length >= 3) {\n    command.x1 = points[1][0];\n    command.y1 = points[1][1];\n  }\n\n  command.x = points[points.length - 1][0];\n  command.y = points[points.length - 1][1];\n\n  if (points.length === 4) {\n    // start, control1, control2, end\n    command.type = 'C';\n  } else if (points.length === 3) {\n    // start, control, end\n    command.type = 'Q';\n  } else {\n    // start, end\n    command.type = 'L';\n  }\n\n  return command;\n}\n/**\n * Runs de Casteljau's algorithm enough times to produce the desired number of segments.\n *\n * @param {Number[][]} points Array of [x,y] points for de Casteljau (the initial segment to split)\n * @param {Number} segmentCount Number of segments to split the original into\n * @return {Number[][][]} Array of segments\n */\n\n\nfunction splitCurveAsPoints(points, segmentCount) {\n  segmentCount = segmentCount || 2;\n  var segments = [];\n  var remainingCurve = points;\n  var tIncrement = 1 / segmentCount; // x-----x-----x-----x\n  // t=  0.33   0.66   1\n  // x-----o-----------x\n  // r=  0.33\n  //       x-----o-----x\n  // r=         0.5  (0.33 / (1 - 0.33))  === tIncrement / (1 - (tIncrement * (i - 1))\n  // x-----x-----x-----x----x\n  // t=  0.25   0.5   0.75  1\n  // x-----o----------------x\n  // r=  0.25\n  //       x-----o----------x\n  // r=         0.33  (0.25 / (1 - 0.25))\n  //             x-----o----x\n  // r=         0.5  (0.25 / (1 - 0.5))\n\n  for (var i = 0; i < segmentCount - 1; i++) {\n    var tRelative = tIncrement / (1 - tIncrement * i);\n    var split = decasteljau(remainingCurve, tRelative);\n    segments.push(split.left);\n    remainingCurve = split.right;\n  } // last segment is just to the end from the last point\n\n\n  segments.push(remainingCurve);\n  return segments;\n}\n/**\n * Convert command objects to arrays of points, run de Casteljau's algorithm on it\n * to split into to the desired number of segments.\n *\n * @param {Object} commandStart The start command object\n * @param {Object} commandEnd The end command object\n * @param {Number} segmentCount The number of segments to create\n * @return {Object[]} An array of commands representing the segments in sequence\n */\n\n\nfunction splitCurve(commandStart, commandEnd, segmentCount) {\n  var points = [[commandStart.x, commandStart.y]];\n\n  if (commandEnd.x1 != null) {\n    points.push([commandEnd.x1, commandEnd.y1]);\n  }\n\n  if (commandEnd.x2 != null) {\n    points.push([commandEnd.x2, commandEnd.y2]);\n  }\n\n  points.push([commandEnd.x, commandEnd.y]);\n  return splitCurveAsPoints(points, segmentCount).map(pointsToCommand);\n}\n\nvar commandTokenRegex = /[MLCSTQAHVZmlcstqahv]|-?[\\d.e+-]+/g;\n/**\n * List of params for each command type in a path `d` attribute\n */\n\nvar typeMap = {\n  M: ['x', 'y'],\n  L: ['x', 'y'],\n  H: ['x'],\n  V: ['y'],\n  C: ['x1', 'y1', 'x2', 'y2', 'x', 'y'],\n  S: ['x2', 'y2', 'x', 'y'],\n  Q: ['x1', 'y1', 'x', 'y'],\n  T: ['x', 'y'],\n  A: ['rx', 'ry', 'xAxisRotation', 'largeArcFlag', 'sweepFlag', 'x', 'y'],\n  Z: []\n}; // Add lower case entries too matching uppercase (e.g. 'm' == 'M')\n\nObject.keys(typeMap).forEach(function (key) {\n  typeMap[key.toLowerCase()] = typeMap[key];\n});\n\nfunction arrayOfLength(length, value) {\n  var array = Array(length);\n\n  for (var i = 0; i < length; i++) {\n    array[i] = value;\n  }\n\n  return array;\n}\n/**\n * Converts a command object to a string to be used in a `d` attribute\n * @param {Object} command A command object\n * @return {String} The string for the `d` attribute\n */\n\n\nfunction commandToString(command) {\n  return \"\".concat(command.type).concat(typeMap[command.type].map(function (p) {\n    return command[p];\n  }).join(','));\n}\n/**\n * Converts command A to have the same type as command B.\n *\n * e.g., L0,5 -> C0,5,0,5,0,5\n *\n * Uses these rules:\n * x1 <- x\n * x2 <- x\n * y1 <- y\n * y2 <- y\n * rx <- 0\n * ry <- 0\n * xAxisRotation <- read from B\n * largeArcFlag <- read from B\n * sweepflag <- read from B\n *\n * @param {Object} aCommand Command object from path `d` attribute\n * @param {Object} bCommand Command object from path `d` attribute to match against\n * @return {Object} aCommand converted to type of bCommand\n */\n\n\nfunction convertToSameType(aCommand, bCommand) {\n  var conversionMap = {\n    x1: 'x',\n    y1: 'y',\n    x2: 'x',\n    y2: 'y'\n  };\n  var readFromBKeys = ['xAxisRotation', 'largeArcFlag', 'sweepFlag']; // convert (but ignore M types)\n\n  if (aCommand.type !== bCommand.type && bCommand.type.toUpperCase() !== 'M') {\n    var aConverted = {};\n    Object.keys(bCommand).forEach(function (bKey) {\n      var bValue = bCommand[bKey]; // first read from the A command\n\n      var aValue = aCommand[bKey]; // if it is one of these values, read from B no matter what\n\n      if (aValue === undefined) {\n        if (readFromBKeys.includes(bKey)) {\n          aValue = bValue;\n        } else {\n          // if it wasn't in the A command, see if an equivalent was\n          if (aValue === undefined && conversionMap[bKey]) {\n            aValue = aCommand[conversionMap[bKey]];\n          } // if it doesn't have a converted value, use 0\n\n\n          if (aValue === undefined) {\n            aValue = 0;\n          }\n        }\n      }\n\n      aConverted[bKey] = aValue;\n    }); // update the type to match B\n\n    aConverted.type = bCommand.type;\n    aCommand = aConverted;\n  }\n\n  return aCommand;\n}\n/**\n * Interpolate between command objects commandStart and commandEnd segmentCount times.\n * If the types are L, Q, or C then the curves are split as per de Casteljau's algorithm.\n * Otherwise we just copy commandStart segmentCount - 1 times, finally ending with commandEnd.\n *\n * @param {Object} commandStart Command object at the beginning of the segment\n * @param {Object} commandEnd Command object at the end of the segment\n * @param {Number} segmentCount The number of segments to split this into. If only 1\n *   Then [commandEnd] is returned.\n * @return {Object[]} Array of ~segmentCount command objects between commandStart and\n *   commandEnd. (Can be segmentCount+1 objects if commandStart is type M).\n */\n\n\nfunction splitSegment(commandStart, commandEnd, segmentCount) {\n  var segments = []; // line, quadratic bezier, or cubic bezier\n\n  if (commandEnd.type === 'L' || commandEnd.type === 'Q' || commandEnd.type === 'C') {\n    segments = segments.concat(splitCurve(commandStart, commandEnd, segmentCount)); // general case - just copy the same point\n  } else {\n    var copyCommand = _extends({}, commandStart); // convert M to L\n\n\n    if (copyCommand.type === 'M') {\n      copyCommand.type = 'L';\n    }\n\n    segments = segments.concat(arrayOfLength(segmentCount - 1).map(function () {\n      return copyCommand;\n    }));\n    segments.push(commandEnd);\n  }\n\n  return segments;\n}\n/**\n * Extends an array of commandsToExtend to the length of the referenceCommands by\n * splitting segments until the number of commands match. Ensures all the actual\n * points of commandsToExtend are in the extended array.\n *\n * @param {Object[]} commandsToExtend The command object array to extend\n * @param {Object[]} referenceCommands The command object array to match in length\n * @param {Function} excludeSegment a function that takes a start command object and\n *   end command object and returns true if the segment should be excluded from splitting.\n * @return {Object[]} The extended commandsToExtend array\n */\n\n\nfunction extend(commandsToExtend, referenceCommands, excludeSegment) {\n  // compute insertion points:\n  // number of segments in the path to extend\n  var numSegmentsToExtend = commandsToExtend.length - 1; // number of segments in the reference path.\n\n  var numReferenceSegments = referenceCommands.length - 1; // this value is always between [0, 1].\n\n  var segmentRatio = numSegmentsToExtend / numReferenceSegments; // create a map, mapping segments in referenceCommands to how many points\n  // should be added in that segment (should always be >= 1 since we need each\n  // point itself).\n  // 0 = segment 0-1, 1 = segment 1-2, n-1 = last vertex\n\n  var countPointsPerSegment = arrayOfLength(numReferenceSegments).reduce(function (accum, d, i) {\n    var insertIndex = Math.floor(segmentRatio * i); // handle excluding segments\n\n    if (excludeSegment && insertIndex < commandsToExtend.length - 1 && excludeSegment(commandsToExtend[insertIndex], commandsToExtend[insertIndex + 1])) {\n      // set the insertIndex to the segment that this point should be added to:\n      // round the insertIndex essentially so we split half and half on\n      // neighbouring segments. hence the segmentRatio * i < 0.5\n      var addToPriorSegment = segmentRatio * i % 1 < 0.5; // only skip segment if we already have 1 point in it (can't entirely remove a segment)\n\n      if (accum[insertIndex]) {\n        // TODO - Note this is a naive algorithm that should work for most d3-area use cases\n        // but if two adjacent segments are supposed to be skipped, this will not perform as\n        // expected. Could be updated to search for nearest segment to place the point in, but\n        // will only do that if necessary.\n        // add to the prior segment\n        if (addToPriorSegment) {\n          if (insertIndex > 0) {\n            insertIndex -= 1; // not possible to add to previous so adding to next\n          } else if (insertIndex < commandsToExtend.length - 1) {\n            insertIndex += 1;\n          } // add to next segment\n\n        } else if (insertIndex < commandsToExtend.length - 1) {\n          insertIndex += 1; // not possible to add to next so adding to previous\n        } else if (insertIndex > 0) {\n          insertIndex -= 1;\n        }\n      }\n    }\n\n    accum[insertIndex] = (accum[insertIndex] || 0) + 1;\n    return accum;\n  }, []); // extend each segment to have the correct number of points for a smooth interpolation\n\n  var extended = countPointsPerSegment.reduce(function (extended, segmentCount, i) {\n    // if last command, just add `segmentCount` number of times\n    if (i === commandsToExtend.length - 1) {\n      var lastCommandCopies = arrayOfLength(segmentCount, _extends({}, commandsToExtend[commandsToExtend.length - 1])); // convert M to L\n\n      if (lastCommandCopies[0].type === 'M') {\n        lastCommandCopies.forEach(function (d) {\n          d.type = 'L';\n        });\n      }\n\n      return extended.concat(lastCommandCopies);\n    } // otherwise, split the segment segmentCount times.\n\n\n    return extended.concat(splitSegment(commandsToExtend[i], commandsToExtend[i + 1], segmentCount));\n  }, []); // add in the very first point since splitSegment only adds in the ones after it\n\n  extended.unshift(commandsToExtend[0]);\n  return extended;\n}\n/**\n * Takes a path `d` string and converts it into an array of command\n * objects. Drops the `Z` character.\n *\n * @param {String|null} d A path `d` string\n */\n\n\nfunction pathCommandsFromString(d) {\n  // split into valid tokens\n  var tokens = (d || '').match(commandTokenRegex) || [];\n  var commands = [];\n  var commandArgs;\n  var command; // iterate over each token, checking if we are at a new command\n  // by presence in the typeMap\n\n  for (var i = 0; i < tokens.length; ++i) {\n    commandArgs = typeMap[tokens[i]]; // new command found:\n\n    if (commandArgs) {\n      command = {\n        type: tokens[i]\n      }; // add each of the expected args for this command:\n\n      for (var a = 0; a < commandArgs.length; ++a) {\n        command[commandArgs[a]] = +tokens[i + a + 1];\n      } // need to increment our token index appropriately since\n      // we consumed token args\n\n\n      i += commandArgs.length;\n      commands.push(command);\n    }\n  }\n\n  return commands;\n}\n/**\n * Interpolate from A to B by extending A and B during interpolation to have\n * the same number of points. This allows for a smooth transition when they\n * have a different number of points.\n *\n * Ignores the `Z` command in paths unless both A and B end with it.\n *\n * This function works directly with arrays of command objects instead of with\n * path `d` strings (see interpolatePath for working with `d` strings).\n *\n * @param {Object[]} aCommandsInput Array of path commands\n * @param {Object[]} bCommandsInput Array of path commands\n * @param {Function} excludeSegment a function that takes a start command object and\n *   end command object and returns true if the segment should be excluded from splitting.\n * @returns {Function} Interpolation function that maps t ([0, 1]) to an array of path commands.\n */\n\nfunction interpolatePathCommands(aCommandsInput, bCommandsInput, excludeSegment) {\n  // make a copy so we don't mess with the input arrays\n  var aCommands = aCommandsInput == null ? [] : aCommandsInput.slice();\n  var bCommands = bCommandsInput == null ? [] : bCommandsInput.slice(); // both input sets are empty, so we don't interpolate\n\n  if (!aCommands.length && !bCommands.length) {\n    return function nullInterpolator() {\n      return [];\n    };\n  } // do we add Z during interpolation? yes if both have it. (we'd expect both to have it or not)\n\n\n  var addZ = (aCommands.length === 0 || aCommands[aCommands.length - 1].type === 'Z') && (bCommands.length === 0 || bCommands[bCommands.length - 1].type === 'Z'); // we temporarily remove Z\n\n  if (aCommands.length > 0 && aCommands[aCommands.length - 1].type === 'Z') {\n    aCommands.pop();\n  }\n\n  if (bCommands.length > 0 && bCommands[bCommands.length - 1].type === 'Z') {\n    bCommands.pop();\n  } // if A is empty, treat it as if it used to contain just the first point\n  // of B. This makes it so the line extends out of from that first point.\n\n\n  if (!aCommands.length) {\n    aCommands.push(bCommands[0]); // otherwise if B is empty, treat it as if it contains the first point\n    // of A. This makes it so the line retracts into the first point.\n  } else if (!bCommands.length) {\n    bCommands.push(aCommands[0]);\n  } // extend to match equal size\n\n\n  var numPointsToExtend = Math.abs(bCommands.length - aCommands.length);\n\n  if (numPointsToExtend !== 0) {\n    // B has more points than A, so add points to A before interpolating\n    if (bCommands.length > aCommands.length) {\n      aCommands = extend(aCommands, bCommands, excludeSegment); // else if A has more points than B, add more points to B\n    } else if (bCommands.length < aCommands.length) {\n      bCommands = extend(bCommands, aCommands, excludeSegment);\n    }\n  } // commands have same length now.\n  // convert commands in A to the same type as those in B\n\n\n  aCommands = aCommands.map(function (aCommand, i) {\n    return convertToSameType(aCommand, bCommands[i]);\n  }); // create mutable interpolated command objects\n\n  var interpolatedCommands = aCommands.map(function (aCommand) {\n    return _objectSpread2({}, aCommand);\n  });\n\n  if (addZ) {\n    interpolatedCommands.push({\n      type: 'Z'\n    });\n  }\n\n  return function pathCommandInterpolator(t) {\n    // at 1 return the final value without the extensions used during interpolation\n    if (t === 1) {\n      return bCommandsInput == null ? [] : bCommandsInput;\n    } // interpolate the commands using the mutable interpolated command objs\n    // we can skip at t=0 since we copied aCommands to begin\n\n\n    if (t > 0) {\n      for (var i = 0; i < interpolatedCommands.length; ++i) {\n        // if (interpolatedCommands[i].type === 'Z') continue;\n        var aCommand = aCommands[i];\n        var bCommand = bCommands[i];\n        var interpolatedCommand = interpolatedCommands[i];\n\n        var _iterator = _createForOfIteratorHelper(typeMap[interpolatedCommand.type]),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var arg = _step.value;\n            interpolatedCommand[arg] = (1 - t) * aCommand[arg] + t * bCommand[arg]; // do not use floats for flags (#27), round to integer\n\n            if (arg === 'largeArcFlag' || arg === 'sweepFlag') {\n              interpolatedCommand[arg] = Math.round(interpolatedCommand[arg]);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    }\n\n    return interpolatedCommands;\n  };\n}\n/**\n * Interpolate from A to B by extending A and B during interpolation to have\n * the same number of points. This allows for a smooth transition when they\n * have a different number of points.\n *\n * Ignores the `Z` character in paths unless both A and B end with it.\n *\n * @param {String} a The `d` attribute for a path\n * @param {String} b The `d` attribute for a path\n * @param {Function} excludeSegment a function that takes a start command object and\n *   end command object and returns true if the segment should be excluded from splitting.\n * @returns {Function} Interpolation function that maps t ([0, 1]) to a path `d` string.\n */\n\nfunction interpolatePath(a, b, excludeSegment) {\n  var aCommands = pathCommandsFromString(a);\n  var bCommands = pathCommandsFromString(b);\n\n  if (!aCommands.length && !bCommands.length) {\n    return function nullInterpolator() {\n      return '';\n    };\n  }\n\n  var commandInterpolator = interpolatePathCommands(aCommands, bCommands, excludeSegment);\n  return function pathStringInterpolator(t) {\n    // at 1 return the final value without the extensions used during interpolation\n    if (t === 1) {\n      return b == null ? '' : b;\n    }\n\n    var interpolatedCommands = commandInterpolator(t); // convert to a string (fastest concat: https://jsperf.com/join-concat/150)\n\n    var interpolatedString = '';\n\n    var _iterator2 = _createForOfIteratorHelper(interpolatedCommands),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var interpolatedCommand = _step2.value;\n        interpolatedString += commandToString(interpolatedCommand);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return interpolatedString;\n  };\n}\n\nexports.interpolatePath = interpolatePath;\nexports.interpolatePathCommands = interpolatePathCommands;\nexports.pathCommandsFromString = pathCommandsFromString;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]},"metadata":{},"sourceType":"script"}