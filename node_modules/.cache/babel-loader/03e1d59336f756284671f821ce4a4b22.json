{"ast":null,"code":"import React, { useContext, useEffect, useMemo } from 'react';\nimport { stack as d3stack } from 'd3-shape';\nimport stackOffset from '@visx/shape/lib/util/stackOffset';\nimport stackOrder from '@visx/shape/lib/util/stackOrder';\nimport { extent } from 'd3-array';\nimport DataContext from '../context/DataContext';\nimport getBarStackRegistryData from '../utils/getBarStackRegistryData';\nimport combineBarStackData from '../utils/combineBarStackData';\nimport getChildrenAndGrandchildrenWithProps from '../utils/getChildrenAndGrandchildrenWithProps';\nexport default function useStackedData(_ref) {\n  var children = _ref.children,\n      order = _ref.order,\n      offset = _ref.offset;\n\n  var _ref2 = useContext(DataContext),\n      horizontal = _ref2.horizontal,\n      registerData = _ref2.registerData,\n      unregisterData = _ref2.unregisterData; // find series children\n  // @TODO: memoization doesn't work well if at all for this\n\n\n  var seriesChildren = useMemo(function () {\n    return getChildrenAndGrandchildrenWithProps(children);\n  }, [children]); // extract data keys from child series\n\n  var dataKeys = useMemo(function () {\n    return seriesChildren.filter(function (child) {\n      return child.props.dataKey;\n    }).map(function (child) {\n      return child.props.dataKey;\n    });\n  }, [seriesChildren]); // group all child data by stack value { [x | y]: { [dataKey]: value } }\n  // this format is needed by d3Stack\n\n  var combinedData = useMemo(function () {\n    return combineBarStackData(seriesChildren, horizontal);\n  }, [horizontal, seriesChildren]); // stack data\n\n  var stackedData = useMemo(function () {\n    // automatically set offset to diverging if it's undefined and negative values are present\n    var hasSomeNegativeValues = offset ? null : combinedData.some(function (d) {\n      return d.negativeSum < 0;\n    });\n    var stack = d3stack();\n    stack.keys(dataKeys);\n    if (order) stack.order(stackOrder(order));\n    if (offset || hasSomeNegativeValues) stack.offset(stackOffset(offset || 'diverging'));\n    return stack(combinedData);\n  }, [combinedData, dataKeys, order, offset]); // update the domain to account for the (directional) stacked value\n\n  var comprehensiveDomain = useMemo(function () {\n    return extent(stackedData.reduce(function (allDatum, stack) {\n      stack.forEach(function (_ref3) {\n        var min = _ref3[0],\n            max = _ref3[1];\n        allDatum.push(min);\n        allDatum.push(max);\n      });\n      return allDatum;\n    }, []));\n  }, [stackedData]); // register all child data using the stack-transformed values\n\n  useEffect(function () {\n    var dataToRegister = getBarStackRegistryData(stackedData, comprehensiveDomain, horizontal);\n    registerData(dataToRegister); // unregister data on unmount\n\n    return function () {\n      return unregisterData(dataKeys);\n    };\n  }, [dataKeys, comprehensiveDomain, horizontal, stackedData, registerData, unregisterData, seriesChildren]);\n  return {\n    seriesChildren: seriesChildren,\n    dataKeys: dataKeys,\n    stackedData: stackedData\n  };\n}","map":{"version":3,"sources":["C:/remotePackRlab-acab49ee44aa8f06acbfc147116dbc3387885161/node_modules/@visx/xychart/esm/hooks/useStackedData.js"],"names":["React","useContext","useEffect","useMemo","stack","d3stack","stackOffset","stackOrder","extent","DataContext","getBarStackRegistryData","combineBarStackData","getChildrenAndGrandchildrenWithProps","useStackedData","_ref","children","order","offset","_ref2","horizontal","registerData","unregisterData","seriesChildren","dataKeys","filter","child","props","dataKey","map","combinedData","stackedData","hasSomeNegativeValues","some","d","negativeSum","keys","comprehensiveDomain","reduce","allDatum","forEach","_ref3","min","max","push","dataToRegister"],"mappings":"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","sourcesContent":["import React, { useContext, useEffect, useMemo } from 'react';\nimport { stack as d3stack } from 'd3-shape';\nimport stackOffset from '@visx/shape/lib/util/stackOffset';\nimport stackOrder from '@visx/shape/lib/util/stackOrder';\nimport { extent } from 'd3-array';\nimport DataContext from '../context/DataContext';\nimport getBarStackRegistryData from '../utils/getBarStackRegistryData';\nimport combineBarStackData from '../utils/combineBarStackData';\nimport getChildrenAndGrandchildrenWithProps from '../utils/getChildrenAndGrandchildrenWithProps';\nexport default function useStackedData(_ref) {\n  var children = _ref.children,\n      order = _ref.order,\n      offset = _ref.offset;\n\n  var _ref2 = useContext(DataContext),\n      horizontal = _ref2.horizontal,\n      registerData = _ref2.registerData,\n      unregisterData = _ref2.unregisterData; // find series children\n  // @TODO: memoization doesn't work well if at all for this\n\n\n  var seriesChildren = useMemo(function () {\n    return getChildrenAndGrandchildrenWithProps(children);\n  }, [children]); // extract data keys from child series\n\n  var dataKeys = useMemo(function () {\n    return seriesChildren.filter(function (child) {\n      return child.props.dataKey;\n    }).map(function (child) {\n      return child.props.dataKey;\n    });\n  }, [seriesChildren]); // group all child data by stack value { [x | y]: { [dataKey]: value } }\n  // this format is needed by d3Stack\n\n  var combinedData = useMemo(function () {\n    return combineBarStackData(seriesChildren, horizontal);\n  }, [horizontal, seriesChildren]); // stack data\n\n  var stackedData = useMemo(function () {\n    // automatically set offset to diverging if it's undefined and negative values are present\n    var hasSomeNegativeValues = offset ? null : combinedData.some(function (d) {\n      return d.negativeSum < 0;\n    });\n    var stack = d3stack();\n    stack.keys(dataKeys);\n    if (order) stack.order(stackOrder(order));\n    if (offset || hasSomeNegativeValues) stack.offset(stackOffset(offset || 'diverging'));\n    return stack(combinedData);\n  }, [combinedData, dataKeys, order, offset]); // update the domain to account for the (directional) stacked value\n\n  var comprehensiveDomain = useMemo(function () {\n    return extent(stackedData.reduce(function (allDatum, stack) {\n      stack.forEach(function (_ref3) {\n        var min = _ref3[0],\n            max = _ref3[1];\n        allDatum.push(min);\n        allDatum.push(max);\n      });\n      return allDatum;\n    }, []));\n  }, [stackedData]); // register all child data using the stack-transformed values\n\n  useEffect(function () {\n    var dataToRegister = getBarStackRegistryData(stackedData, comprehensiveDomain, horizontal);\n    registerData(dataToRegister); // unregister data on unmount\n\n    return function () {\n      return unregisterData(dataKeys);\n    };\n  }, [dataKeys, comprehensiveDomain, horizontal, stackedData, registerData, unregisterData, seriesChildren]);\n  return {\n    seriesChildren: seriesChildren,\n    dataKeys: dataKeys,\n    stackedData: stackedData\n  };\n}"]},"metadata":{},"sourceType":"module"}