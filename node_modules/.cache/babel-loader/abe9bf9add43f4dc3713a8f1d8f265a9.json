{"ast":null,"code":"import _pt from \"prop-types\";\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport React, { useContext } from 'react';\nimport cx from 'classnames';\nimport AnnotationContext from '../context/AnnotationContext'; // @TODO\n// add end marker support\n\nexport default function Connector(_ref) {\n  var _annotationContext$x, _annotationContext$y, _annotationContext$dx, _annotationContext$dy;\n\n  var className = _ref.className,\n      propsX = _ref.x,\n      propsY = _ref.y,\n      propsDx = _ref.dx,\n      propsDy = _ref.dy,\n      _ref$type = _ref.type,\n      type = _ref$type === void 0 ? 'elbow' : _ref$type,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === void 0 ? '#222' : _ref$stroke,\n      pathProps = _ref.pathProps; // if props are provided, they take precedence over context\n\n  var annotationContext = useContext(AnnotationContext);\n  var x0 = propsX == null ? (_annotationContext$x = annotationContext.x) != null ? _annotationContext$x : 0 : propsX;\n  var y0 = propsY == null ? (_annotationContext$y = annotationContext.y) != null ? _annotationContext$y : 0 : propsY;\n  var dx = propsDx == null ? (_annotationContext$dx = annotationContext.dx) != null ? _annotationContext$dx : 0 : propsDx;\n  var dy = propsDy == null ? (_annotationContext$dy = annotationContext.dy) != null ? _annotationContext$dy : 0 : propsDy;\n  var x1 = x0; // only used with elbow type\n\n  var y1 = y0;\n  var x2 = x0 + dx;\n  var y2 = y0 + dy;\n\n  if (type === 'elbow') {\n    // if dx < dy, find the intesection of y=x or y=-x from subject, with vertical line to label\n    if (Math.abs(dx) <= Math.abs(dy)) {\n      // target line is vertical x = x2\n      x1 = x2; // intersection with y=x line (if dy > 0) or y=x (if dy < 0)\n\n      var sign = dy > 0 ? 1 : -1;\n      y1 = y0 + sign * Math.abs(x1 - x0);\n    } // if dx > dy, find the intesection of y=x or y=-x from subject, with horizontal line to label\n    else {\n        // target line is horizontal y = y2\n        y1 = y2; // find intersection with y=-x line (if dx > 0) or y=x (if dx < 0)\n\n        var _sign = dx > 0 ? 1 : -1;\n\n        x1 = x0 + _sign * Math.abs(y1 - y0);\n      }\n  }\n\n  return /*#__PURE__*/React.createElement(\"path\", _extends({\n    className: cx('visx-annotation-connector', className),\n    strokeWidth: 1,\n    stroke: stroke,\n    fill: \"transparent\",\n    pointerEvents: \"none\",\n    d: \"M\" + x0 + \",\" + y0 + (type === 'elbow' ? \"L\" + x1 + \",\" + y1 : '') + \"L\" + x2 + \",\" + y2\n  }, pathProps));\n}\nConnector.propTypes = {\n  className: _pt.string,\n  type: _pt.oneOf(['line', 'elbow']),\n  stroke: _pt.string\n};","map":{"version":3,"sources":["C:/remotePackRlab-acab49ee44aa8f06acbfc147116dbc3387885161/node_modules/@visx/annotation/esm/components/Connector.js"],"names":["_pt","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","React","useContext","cx","AnnotationContext","Connector","_ref","_annotationContext$x","_annotationContext$y","_annotationContext$dx","_annotationContext$dy","className","propsX","x","propsY","y","propsDx","dx","propsDy","dy","_ref$type","type","_ref$stroke","stroke","pathProps","annotationContext","x0","y0","x1","y1","x2","y2","Math","abs","sign","_sign","createElement","strokeWidth","fill","pointerEvents","d","propTypes","string","oneOf"],"mappings":"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","sourcesContent":["import _pt from \"prop-types\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React, { useContext } from 'react';\nimport cx from 'classnames';\nimport AnnotationContext from '../context/AnnotationContext'; // @TODO\n// add end marker support\n\nexport default function Connector(_ref) {\n  var _annotationContext$x, _annotationContext$y, _annotationContext$dx, _annotationContext$dy;\n\n  var className = _ref.className,\n      propsX = _ref.x,\n      propsY = _ref.y,\n      propsDx = _ref.dx,\n      propsDy = _ref.dy,\n      _ref$type = _ref.type,\n      type = _ref$type === void 0 ? 'elbow' : _ref$type,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === void 0 ? '#222' : _ref$stroke,\n      pathProps = _ref.pathProps;\n  // if props are provided, they take precedence over context\n  var annotationContext = useContext(AnnotationContext);\n  var x0 = propsX == null ? (_annotationContext$x = annotationContext.x) != null ? _annotationContext$x : 0 : propsX;\n  var y0 = propsY == null ? (_annotationContext$y = annotationContext.y) != null ? _annotationContext$y : 0 : propsY;\n  var dx = propsDx == null ? (_annotationContext$dx = annotationContext.dx) != null ? _annotationContext$dx : 0 : propsDx;\n  var dy = propsDy == null ? (_annotationContext$dy = annotationContext.dy) != null ? _annotationContext$dy : 0 : propsDy;\n  var x1 = x0; // only used with elbow type\n\n  var y1 = y0;\n  var x2 = x0 + dx;\n  var y2 = y0 + dy;\n\n  if (type === 'elbow') {\n    // if dx < dy, find the intesection of y=x or y=-x from subject, with vertical line to label\n    if (Math.abs(dx) <= Math.abs(dy)) {\n      // target line is vertical x = x2\n      x1 = x2; // intersection with y=x line (if dy > 0) or y=x (if dy < 0)\n\n      var sign = dy > 0 ? 1 : -1;\n      y1 = y0 + sign * Math.abs(x1 - x0);\n    } // if dx > dy, find the intesection of y=x or y=-x from subject, with horizontal line to label\n    else {\n        // target line is horizontal y = y2\n        y1 = y2; // find intersection with y=-x line (if dx > 0) or y=x (if dx < 0)\n\n        var _sign = dx > 0 ? 1 : -1;\n\n        x1 = x0 + _sign * Math.abs(y1 - y0);\n      }\n  }\n\n  return /*#__PURE__*/React.createElement(\"path\", _extends({\n    className: cx('visx-annotation-connector', className),\n    strokeWidth: 1,\n    stroke: stroke,\n    fill: \"transparent\",\n    pointerEvents: \"none\",\n    d: \"M\" + x0 + \",\" + y0 + (type === 'elbow' ? \"L\" + x1 + \",\" + y1 : '') + \"L\" + x2 + \",\" + y2\n  }, pathProps));\n}\nConnector.propTypes = {\n  className: _pt.string,\n  type: _pt.oneOf(['line', 'elbow']),\n  stroke: _pt.string\n};"]},"metadata":{},"sourceType":"module"}