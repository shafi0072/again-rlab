{"ast":null,"code":"import { bisector, range as d3Range, bisectLeft } from 'd3-array'; // @TODO make more robust to null/undefined scaled values\n\n/** Finds the nearest datum in a single direction (x or y) closest to the specified `scaledValue`. */\n\nexport default function findNearestDatumSingleDimension(_ref) {\n  var scale = _ref.scale,\n      accessor = _ref.accessor,\n      scaledValue = _ref.scaledValue,\n      data = _ref.data;\n  var coercedScale = scale; // broaden type before type guards below\n\n  var nearestDatum;\n  var nearestDatumIndex; // if scale has .invert(), convert svg coord to nearest data value\n\n  if ('invert' in coercedScale && typeof coercedScale.invert === 'function') {\n    var bisect = bisector(accessor).left; // find closest data value, then map that to closest datum\n\n    var dataValue = Number(coercedScale.invert(scaledValue));\n    var index = bisect(data, dataValue); // take the two datum nearest this index, and compute which is closer\n\n    var nearestDatum0 = data[index - 1];\n    var nearestDatum1 = data[index];\n    nearestDatum = !nearestDatum0 || Math.abs(dataValue - accessor(nearestDatum0)) > Math.abs(dataValue - accessor(nearestDatum1)) ? nearestDatum1 : nearestDatum0;\n    nearestDatumIndex = nearestDatum === nearestDatum0 ? index - 1 : index;\n  } else if ('step' in coercedScale && typeof coercedScale.step !== 'undefined') {\n    // band scales don't have an invert function but they do have discrete domains\n    // so we manually invert\n    var domain = scale.domain();\n    var range = scale.range().map(Number);\n    var sortedRange = [].concat(range).sort(function (a, b) {\n      return a - b;\n    }); // bisectLeft assumes sort\n\n    var rangePoints = d3Range(sortedRange[0], sortedRange[1], coercedScale.step());\n    var domainIndex = bisectLeft(rangePoints, scaledValue); // y-axis scales may have reverse ranges, correct for this\n\n    var sortedDomain = range[0] < range[1] ? domain : domain.reverse();\n    var domainValue = sortedDomain[domainIndex - 1];\n\n    var _index = data.findIndex(function (d) {\n      return String(accessor(d)) === String(domainValue);\n    });\n\n    nearestDatum = data[_index];\n    nearestDatumIndex = _index;\n  } else {\n    console.warn('[visx/xychart/findNearestDatum] encountered incompatible scale type, bailing');\n    return null;\n  }\n\n  if (nearestDatum == null || nearestDatumIndex == null) return null;\n  var distance = Math.abs(Number(coercedScale(accessor(nearestDatum))) - scaledValue);\n  return {\n    datum: nearestDatum,\n    index: nearestDatumIndex,\n    distance: distance\n  };\n}","map":{"version":3,"sources":["C:/remotePackRlab-acab49ee44aa8f06acbfc147116dbc3387885161/node_modules/@visx/xychart/esm/utils/findNearestDatumSingleDimension.js"],"names":["bisector","range","d3Range","bisectLeft","findNearestDatumSingleDimension","_ref","scale","accessor","scaledValue","data","coercedScale","nearestDatum","nearestDatumIndex","invert","bisect","left","dataValue","Number","index","nearestDatum0","nearestDatum1","Math","abs","step","domain","map","sortedRange","concat","sort","a","b","rangePoints","domainIndex","sortedDomain","reverse","domainValue","_index","findIndex","d","String","console","warn","distance","datum"],"mappings":"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","sourcesContent":["import { bisector, range as d3Range, bisectLeft } from 'd3-array'; // @TODO make more robust to null/undefined scaled values\n\n/** Finds the nearest datum in a single direction (x or y) closest to the specified `scaledValue`. */\n\nexport default function findNearestDatumSingleDimension(_ref) {\n  var scale = _ref.scale,\n      accessor = _ref.accessor,\n      scaledValue = _ref.scaledValue,\n      data = _ref.data;\n  var coercedScale = scale; // broaden type before type guards below\n\n  var nearestDatum;\n  var nearestDatumIndex; // if scale has .invert(), convert svg coord to nearest data value\n\n  if ('invert' in coercedScale && typeof coercedScale.invert === 'function') {\n    var bisect = bisector(accessor).left; // find closest data value, then map that to closest datum\n\n    var dataValue = Number(coercedScale.invert(scaledValue));\n    var index = bisect(data, dataValue); // take the two datum nearest this index, and compute which is closer\n\n    var nearestDatum0 = data[index - 1];\n    var nearestDatum1 = data[index];\n    nearestDatum = !nearestDatum0 || Math.abs(dataValue - accessor(nearestDatum0)) > Math.abs(dataValue - accessor(nearestDatum1)) ? nearestDatum1 : nearestDatum0;\n    nearestDatumIndex = nearestDatum === nearestDatum0 ? index - 1 : index;\n  } else if ('step' in coercedScale && typeof coercedScale.step !== 'undefined') {\n    // band scales don't have an invert function but they do have discrete domains\n    // so we manually invert\n    var domain = scale.domain();\n    var range = scale.range().map(Number);\n    var sortedRange = [].concat(range).sort(function (a, b) {\n      return a - b;\n    }); // bisectLeft assumes sort\n\n    var rangePoints = d3Range(sortedRange[0], sortedRange[1], coercedScale.step());\n    var domainIndex = bisectLeft(rangePoints, scaledValue); // y-axis scales may have reverse ranges, correct for this\n\n    var sortedDomain = range[0] < range[1] ? domain : domain.reverse();\n    var domainValue = sortedDomain[domainIndex - 1];\n\n    var _index = data.findIndex(function (d) {\n      return String(accessor(d)) === String(domainValue);\n    });\n\n    nearestDatum = data[_index];\n    nearestDatumIndex = _index;\n  } else {\n    console.warn('[visx/xychart/findNearestDatum] encountered incompatible scale type, bailing');\n    return null;\n  }\n\n  if (nearestDatum == null || nearestDatumIndex == null) return null;\n  var distance = Math.abs(Number(coercedScale(accessor(nearestDatum))) - scaledValue);\n  return {\n    datum: nearestDatum,\n    index: nearestDatumIndex,\n    distance: distance\n  };\n}"]},"metadata":{},"sourceType":"module"}