{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subscription = void 0;\n\nconst promisify_1 = require(\"@google-cloud/promisify\");\n\nconst events_1 = require(\"events\");\n\nconst extend = require(\"extend\");\n\nconst snakeCase = require(\"lodash.snakecase\");\n\nconst iam_1 = require(\"./iam\");\n\nconst snapshot_1 = require(\"./snapshot\");\n\nconst subscriber_1 = require(\"./subscriber\"); // JSDoc won't see these, so this is just to let you get typings\n// in your editor of choice.\n//\n// NOTE: These are commented out for now because we don't want to\n// break any existing clients that rely on not-entirely-correct\n// typings. We'll re-enable on the next major.\n\n/* export declare interface Subscription {\n  on(\n    event: 'message',\n    listener: (message: Message) => void\n  ): this;\n  on(\n    event: 'error',\n    listener: (error: StatusError) => void\n  ): this;\n  on(event: 'close', listener: () => void): this;\n\n  // Only used internally.\n  on(event: 'newListener', listener: Function): this;\n  on(event: 'removeListener', listener: Function): this;\n\n  // Catch-all. If you get an error about this line, it means you're\n  // using an unsupported event type or listener type.\n  on(event: string, listener: void): this;\n} */\n\n/**\n * @typedef {object} ExpirationPolicy\n * A policy that specifies the conditions for this subscription's expiration. A\n * subscription is considered active as long as any connected subscriber is\n * successfully consuming messages from the subscription or is issuing\n * operations on the subscription. If expirationPolicy is not set, a default\n * policy with ttl of 31 days will be used. The minimum allowed value for\n * expirationPolicy.ttl is 1 day.\n * @property {google.protobuf.Duration} ttl Specifies the \"time-to-live\"\n *     duration for an associated resource. The resource expires if it is not\n *     active for a period of `ttl`. The definition of \"activity\" depends on the\n *     type of the associated resource. The minimum and maximum allowed values\n *     for `ttl` depend on the type of the associated resource, as well. If\n *     `ttl` is not set, the associated resource never expires.\n */\n\n/**\n * A Subscription object will give you access to your Cloud Pub/Sub\n * subscription.\n *\n * Subscriptions are sometimes retrieved when using various methods:\n *\n * - {@link PubSub#getSubscriptions}\n * - {@link Topic#getSubscriptions}\n *\n * Subscription objects may be created directly with:\n *\n * - {@link PubSub#createSubscription}\n * - {@link Topic#createSubscription}\n *\n * All Subscription objects are instances of an\n * [EventEmitter](http://nodejs.org/api/events.html). The subscription will pull\n * for messages automatically as long as there is at least one listener assigned\n * for the `message` event. Available events:\n *\n * Upon receipt of a message:\n * on(event: 'message', listener: (message: {@link Message}) => void): this;\n *\n * Upon receipt of an error:\n * on(event: 'error', listener: (error: Error) => void): this;\n *\n * Upon the closing of the subscriber:\n * on(event: 'close', listener: Function): this;\n *\n * By default Subscription objects allow you to process 100 messages at the same\n * time. You can fine tune this value by adjusting the\n * `options.flowControl.maxMessages` option.\n *\n * If your subscription is seeing more re-deliveries than preferable, you might\n * try increasing your `options.ackDeadline` value or decreasing the\n * `options.streamingOptions.maxStreams` value.\n *\n * Subscription objects handle ack management, by automatically extending the\n * ack deadline while the message is being processed, to then issue the ack or\n * nack of such message when the processing is done. **Note:** message\n * redelivery is still possible.\n *\n * By default each {@link PubSub} instance can handle 100 open streams, with\n * default options this translates to less than 20 Subscriptions per PubSub\n * instance. If you wish to create more Subscriptions than that, you can either\n * create multiple PubSub instances or lower the\n * `options.streamingOptions.maxStreams` value on each Subscription object.\n *\n * @class\n *\n * @param {PubSub} pubsub PubSub object.\n * @param {string} name The name of the subscription.\n * @param {SubscriberOptions} [options] Options for handling messages.\n *\n * @example <caption>From {@link PubSub#getSubscriptions}</caption>\n * const {PubSub} = require('@google-cloud/pubsub');\n * const pubsub = new PubSub();\n *\n * pubsub.getSubscriptions((err, subscriptions) => {\n *   // `subscriptions` is an array of Subscription objects.\n * });\n *\n * @example <caption>From {@link Topic#getSubscriptions}</caption>\n * const topic = pubsub.topic('my-topic');\n * topic.getSubscriptions((err, subscriptions) => {\n *   // `subscriptions` is an array of Subscription objects.\n * });\n *\n * @example <caption>{@link Topic#createSubscription}</caption>\n * const topic = pubsub.topic('my-topic');\n * topic.createSubscription('new-subscription', (err, subscription) => {\n *   // `subscription` is a Subscription object.\n * });\n *\n * @example <caption>{@link Topic#subscription}</caption>\n * const topic = pubsub.topic('my-topic');\n * const subscription = topic.subscription('my-subscription');\n * // `subscription` is a Subscription object.\n *\n * @example <caption>Once you have obtained a subscription object, you may begin\n * to register listeners. This will automatically trigger pulling for messages.\n * </caption>\n * // Register an error handler.\n * subscription.on('error', (err) => {});\n *\n * // Register a close handler in case the subscriber closes unexpectedly\n * subscription.on('close', () => {});\n *\n * // Register a listener for `message` events.\n * function onMessage(message) {\n *   // Called every time a message is received.\n *\n *   // message.id = ID of the message.\n *   // message.ackId = ID used to acknowledge the message receival.\n *   // message.data = Contents of the message.\n *   // message.attributes = Attributes of the message.\n *   // message.publishTime = Date when Pub/Sub received the message.\n *\n *   // Ack the message:\n *   // message.ack();\n *\n *   // This doesn't ack the message, but allows more messages to be retrieved\n *   // if your limit was hit or if you don't want to ack the message.\n *   // message.nack();\n * }\n * subscription.on('message', onMessage);\n *\n * // Remove the listener from receiving `message` events.\n * subscription.removeListener('message', onMessage);\n *\n * @example <caption>To apply a fine level of flow control, consider the\n * following configuration</caption>\n * const subscription = topic.subscription('my-sub', {\n *   flowControl: {\n *     maxMessages: 1,\n *     // this tells the client to manage and lock any excess messages\n *     allowExcessMessages: false\n *   }\n * });\n */\n\n\nclass Subscription extends events_1.EventEmitter {\n  constructor(pubsub, name, options) {\n    super();\n    options = options || {};\n    this.pubsub = pubsub;\n    this.request = pubsub.request.bind(pubsub);\n    this.name = Subscription.formatName_(this.projectId, name);\n    this.topic = options.topic;\n    /**\n     * [IAM (Identity and Access\n     * Management)](https://cloud.google.com/pubsub/access_control) allows you\n     * to set permissions on individual resources and offers a wider range of\n     * roles: editor, owner, publisher, subscriber, and viewer. This gives you\n     * greater flexibility and allows you to set more fine-grained access\n     * control.\n     *\n     * *The IAM access control features described in this document are Beta,\n     * including the API methods to get and set IAM policies, and to test IAM\n     * permissions. Cloud Pub/Sub's use of IAM features is not covered by\n     * any SLA or deprecation policy, and may be subject to\n     * backward-incompatible changes.*\n     *\n     * @name Subscription#iam\n     * @mixes IAM\n     *\n     * @see [Access Control Overview]{@link https://cloud.google.com/pubsub/access_control}\n     * @see [What is Cloud IAM?]{@link https://cloud.google.com/iam/}\n     *\n     * @example\n     * //-\n     * // Get the IAM policy for your subscription.\n     * //-\n     * subscription.iam.getPolicy((err, policy) => {\n     *   console.log(policy);\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * subscription.iam.getPolicy().then((data) => {\n     *   const policy = data[0];\n     *   const apiResponse = data[1];\n     * });\n     */\n\n    this.iam = new iam_1.IAM(pubsub, this.name);\n    this._subscriber = new subscriber_1.Subscriber(this, options);\n\n    this._subscriber.on('error', err => this.emit('error', err)).on('message', message => this.emit('message', message)).on('close', () => this.emit('close'));\n\n    this._listen();\n  }\n  /**\n   * Indicates if the Subscription is open and receiving messages.\n   *\n   * @type {boolean}\n   */\n\n\n  get isOpen() {\n    return !!(this._subscriber && this._subscriber.isOpen);\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get projectId() {\n    return this.pubsub && this.pubsub.projectId || '{{projectId}}';\n  }\n  /**\n   * Closes the Subscription, once this is called you will no longer receive\n   * message events unless you call {Subscription#open} or add new message\n   * listeners.\n   *\n   * @param {function} [callback] The callback function.\n   * @param {?error} callback.err An error returned while closing the\n   *     Subscription.\n   *\n   * @example\n   * subscription.close(err => {\n   *   if (err) {\n   *     // Error handling omitted.\n   *   }\n   * });\n   *\n   * // If the callback is omitted a Promise will be returned.\n   * subscription.close().then(() => {});\n   */\n\n\n  close(callback) {\n    this._subscriber.close().then(() => callback(), callback);\n  }\n  /**\n   * Create a subscription.\n   *\n   * @see [Subscriptions: create API Documentation]{@link https://cloud.google.com/pubsub/docs/reference/rest/v1/projects.subscriptions/create}\n   *\n   * @throws {Error} If subscription name is omitted.\n   *\n   * @param {string} name The name of the subscription.\n   * @param {CreateSubscriptionRequest} [options] See a\n   *     [Subscription\n   * resource](https://cloud.google.com/pubsub/docs/reference/rest/v1/projects.subscriptions).\n   * @param {CreateSubscriptionCallback} [callback] Callback function.\n   * @returns {Promise<CreateSubscriptionResponse>}\n   *\n   * @example\n   * const {PubSub} = require('@google-cloud/pubsub');\n   * const pubsub = new PubSub();\n   *\n   * const topic = pubsub.topic('my-topic');\n   * const subscription = topic.subscription('newMessages');\n   * const callback = function(err, subscription, apiResponse) {};\n   *\n   * subscription.create(callback);\n   *\n   * @example <caption>With options</caption>\n   * subscription.create({\n   *   ackDeadlineSeconds: 90\n   * }, callback);\n   *\n   * @example <caption>If the callback is omitted, we'll return a\n   * Promise.</caption> const [sub, apiResponse] = await subscription.create();\n   */\n\n\n  create(optsOrCallback, callback) {\n    if (!this.topic) {\n      throw new Error('Subscriptions can only be created when accessed through Topics');\n    }\n\n    const name = this.name.split('/').pop();\n    const options = typeof optsOrCallback === 'object' ? optsOrCallback : {};\n    callback = typeof optsOrCallback === 'function' ? optsOrCallback : callback;\n    this.pubsub.createSubscription(this.topic, name, options, (err, sub, resp) => {\n      if (err) {\n        callback(err, null, resp);\n        return;\n      }\n\n      Object.assign(this, sub);\n      callback(null, this, resp);\n    });\n  }\n  /**\n   * @typedef {array} CreateSnapshotResponse\n   * @property {Snapshot} 0 The new {@link Snapshot}.\n   * @property {object} 1 The full API response.\n   */\n\n  /**\n   * @callback CreateSnapshotCallback\n   * @param {?Error} err Request error, if any.\n   * @param {Snapshot} snapshot The new {@link Snapshot}.\n   * @param {object} apiResponse The full API response.\n   */\n\n  /**\n   * Create a snapshot with the given name.\n   *\n   * @param {string} name Name of the snapshot.\n   * @param {object} [gaxOpts] Request configuration options, outlined\n   *     here: https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html.\n   * @param {CreateSnapshotCallback} [callback] Callback function.\n   * @returns {Promise<CreateSnapshotResponse>}\n   *\n   * @example\n   * const {PubSub} = require('@google-cloud/pubsub');\n   * const pubsub = new PubSub();\n   *\n   * const topic = pubsub.topic('my-topic');\n   * const subscription = topic.subscription('my-subscription');\n   *\n   * const callback = (err, snapshot, apiResponse) => {\n   *   if (!err) {\n   *     // The snapshot was created successfully.\n   *   }\n   * };\n   *\n   * subscription.createSnapshot('my-snapshot', callback);\n   *\n   * //-\n   * // If the callback is omitted, we'll return a Promise.\n   * //-\n   * subscription.createSnapshot('my-snapshot').then((data) => {\n   *   const snapshot = data[0];\n   *   const apiResponse = data[1];\n   * });\n   */\n\n\n  createSnapshot(name, optsOrCallback, callback) {\n    if (typeof name !== 'string') {\n      throw new Error('A name is required to create a snapshot.');\n    }\n\n    const gaxOpts = typeof optsOrCallback === 'object' ? optsOrCallback : {};\n    callback = typeof optsOrCallback === 'function' ? optsOrCallback : callback;\n    const snapshot = this.snapshot(name);\n    const reqOpts = {\n      name: snapshot.name,\n      subscription: this.name\n    };\n    this.request({\n      client: 'SubscriberClient',\n      method: 'createSnapshot',\n      reqOpts,\n      gaxOpts\n    }, (err, resp) => {\n      if (err) {\n        callback(err, null, resp);\n        return;\n      }\n\n      snapshot.metadata = resp;\n      callback(null, snapshot, resp);\n    });\n  }\n  /**\n   * Delete the subscription. Pull requests from the current subscription will\n   * be errored once unsubscription is complete.\n   *\n   * @see [Subscriptions: delete API Documentation]{@link https://cloud.google.com/pubsub/docs/reference/rest/v1/projects.subscriptions/delete}\n   *\n   * @param {object} [gaxOpts] Request configuration options, outlined\n   *     here: https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html.\n   * @param {function} [callback] The callback function.\n   * @param {?error} callback.err An error returned while making this\n   *     request.\n   * @param {object} callback.apiResponse Raw API response.\n   *\n   * @example\n   * const {PubSub} = require('@google-cloud/pubsub');\n   * const pubsub = new PubSub();\n   *\n   * const topic = pubsub.topic('my-topic');\n   * const subscription = topic.subscription('my-subscription');\n   *\n   * subscription.delete((err, apiResponse) => {});\n   *\n   * //-\n   * // If the callback is omitted, we'll return a Promise.\n   * //-\n   * subscription.delete().then((data) => {\n   *   const apiResponse = data[0];\n   * });\n   */\n\n\n  delete(optsOrCallback, callback) {\n    const gaxOpts = typeof optsOrCallback === 'object' ? optsOrCallback : {};\n    callback = typeof optsOrCallback === 'function' ? optsOrCallback : callback;\n    const reqOpts = {\n      subscription: this.name\n    };\n\n    if (this.isOpen) {\n      this._subscriber.close();\n    }\n\n    this.request({\n      client: 'SubscriberClient',\n      method: 'deleteSubscription',\n      reqOpts,\n      gaxOpts\n    }, callback);\n  }\n  /**\n   * @typedef {array} SubscriptionDetachedResponse\n   * @property {boolean} 0 Whether the subscription is detached.\n   */\n\n  /**\n   * @callback SubscriptionDetachedCallback\n   * @param {?Error} err Request error, if any.\n   * @param {boolean} exists Whether the subscription is detached.\n   */\n\n  /**\n   * Check if a subscription is detached.\n   *\n   * @param {SubscriptionDetachedCallback} [callback] Callback function.\n   * @returns {Promise<SubscriptionDetachedResponse>}\n   *\n   * @example\n   * const {PubSub} = require('@google-cloud/pubsub');\n   * const pubsub = new PubSub();\n   *\n   * const topic = pubsub.topic('my-topic');\n   * const subscription = topic.subscription('my-subscription');\n   *\n   * subscription.detached((err, exists) => {});\n   *\n   * //-\n   * // If the callback is omitted, we'll return a Promise.\n   * //-\n   * subscription.detached().then((data) => {\n   *   const detached = data[0];\n   * });\n   */\n\n\n  detached(callback) {\n    this.getMetadata((err, metadata) => {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, metadata.detached);\n      }\n    });\n  }\n  /**\n   * @typedef {array} SubscriptionExistsResponse\n   * @property {boolean} 0 Whether the subscription exists\n   */\n\n  /**\n   * @callback SubscriptionExistsCallback\n   * @param {?Error} err Request error, if any.\n   * @param {boolean} exists Whether the subscription exists.\n   */\n\n  /**\n   * Check if a subscription exists.\n   *\n   * @param {SubscriptionExistsCallback} [callback] Callback function.\n   * @returns {Promise<SubscriptionExistsResponse>}\n   *\n   * @example\n   * const {PubSub} = require('@google-cloud/pubsub');\n   * const pubsub = new PubSub();\n   *\n   * const topic = pubsub.topic('my-topic');\n   * const subscription = topic.subscription('my-subscription');\n   *\n   * subscription.exists((err, exists) => {});\n   *\n   * //-\n   * // If the callback is omitted, we'll return a Promise.\n   * //-\n   * subscription.exists().then((data) => {\n   *   const exists = data[0];\n   * });\n   */\n\n\n  exists(callback) {\n    this.getMetadata(err => {\n      if (!err) {\n        callback(null, true);\n        return;\n      }\n\n      if (err.code === 5) {\n        callback(null, false);\n        return;\n      }\n\n      callback(err);\n    });\n  }\n  /**\n   * @typedef {array} GetSubscriptionResponse\n   * @property {Subscription} 0 The {@link Subscription}.\n   * @property {object} 1 The full API response.\n   */\n\n  /**\n   * @callback GetSubscriptionCallback\n   * @param {?Error} err Request error, if any.\n   * @param {Subscription} subscription The {@link Subscription}.\n   * @param {object} apiResponse The full API response.\n   */\n\n  /**\n   * Get a subscription if it exists.\n   *\n   * @param {object} [gaxOpts] Request configuration options, outlined\n   *     here: https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html.\n   * @param {boolean} [gaxOpts.autoCreate=false] Automatically create the\n   *     subscription if it does not already exist.\n   * @param {GetSubscriptionCallback} [callback] Callback function.\n   * @returns {Promise<GetSubscriptionResponse>}\n   *\n   * @example\n   * const {PubSub} = require('@google-cloud/pubsub');\n   * const pubsub = new PubSub();\n   *\n   * const topic = pubsub.topic('my-topic');\n   * const subscription = topic.subscription('my-subscription');\n   *\n   * subscription.get((err, subscription, apiResponse) => {\n   *   // The `subscription` data has been populated.\n   * });\n   *\n   * //-\n   * // If the callback is omitted, we'll return a Promise.\n   * //-\n   * subscription.get().then((data) => {\n   *   const subscription = data[0];\n   *   const apiResponse = data[1];\n   * });\n   */\n\n\n  get(optsOrCallback, callback) {\n    const gaxOpts = typeof optsOrCallback === 'object' ? optsOrCallback : {};\n    callback = typeof optsOrCallback === 'function' ? optsOrCallback : callback;\n    const autoCreate = !!gaxOpts.autoCreate && this.topic;\n    delete gaxOpts.autoCreate;\n    this.getMetadata(gaxOpts, (err, apiResponse) => {\n      if (!err) {\n        callback(null, this, apiResponse);\n        return;\n      }\n\n      if (err.code !== 5 || !autoCreate) {\n        callback(err, null, apiResponse);\n        return;\n      }\n\n      this.create({\n        gaxOpts\n      }, callback);\n    });\n  }\n  /**\n   * @typedef {array} GetSubscriptionMetadataResponse\n   * @property {object} 0 The full API response.\n   */\n\n  /**\n   * @callback GetSubscriptionMetadataCallback\n   * @param {?Error} err Request error, if any.\n   * @param {object} apiResponse The full API response.\n   */\n\n  /**\n   * Fetches the subscriptions metadata.\n   *\n   * @param {object} [gaxOpts] Request configuration options, outlined\n   *     here: https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html.\n   * @param {GetSubscriptionMetadataCallback} [callback] Callback function.\n   * @returns {Promise<GetSubscriptionMetadataResponse>}\n   *\n   * @example\n   * const {PubSub} = require('@google-cloud/pubsub');\n   * const pubsub = new PubSub();\n   *\n   * const topic = pubsub.topic('my-topic');\n   * const subscription = topic.subscription('my-subscription');\n   *\n   * subscription.getMetadata((err, apiResponse) => {\n   *   if (err) {\n   *     // Error handling omitted.\n   *   }\n   * });\n   *\n   * //-\n   * // If the callback is omitted, we'll return a Promise.\n   * //-\n   * subscription.getMetadata().then((data) => {\n   *   const apiResponse = data[0];\n   * });\n   */\n\n\n  getMetadata(optsOrCallback, callback) {\n    const gaxOpts = typeof optsOrCallback === 'object' ? optsOrCallback : {};\n    callback = typeof optsOrCallback === 'function' ? optsOrCallback : callback;\n    const reqOpts = {\n      subscription: this.name\n    };\n    this.request({\n      client: 'SubscriberClient',\n      method: 'getSubscription',\n      reqOpts,\n      gaxOpts\n    }, (err, apiResponse) => {\n      if (!err) {\n        this.metadata = apiResponse;\n      }\n\n      callback(err, apiResponse);\n    });\n  }\n  /**\n   * @typedef {array} ModifyPushConfigResponse\n   * @property {object} 0 The full API response.\n   */\n\n  /**\n   * @callback ModifyPushConfigCallback\n   * @param {?Error} err Request error, if any.\n   * @param {object} apiResponse The full API response.\n   */\n\n  /**\n   * Modify the push config for the subscription.\n   *\n   * @param {object} config The push config.\n   * @param {string} config.pushEndpoint A URL locating the endpoint to which\n   *     messages should be published.\n   * @param {object} config.attributes [PushConfig attributes](https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#google.pubsub.v1.PushConfig).\n   * @param {object} config.oidcToken If specified, Pub/Sub will generate and\n   *     attach an OIDC JWT token as an `Authorization` header in the HTTP\n   *     request for every pushed message. This object should have the same\n   *     structure as [OidcToken]{@link google.pubsub.v1.OidcToken}\n   * @param {object} [gaxOpts] Request configuration options, outlined\n   *     here: https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html.\n   * @param {ModifyPushConfigCallback} [callback] Callback function.\n   * @returns {Promise<ModifyPushConfigResponse>}\n   *\n   * @example\n   * const {PubSub} = require('@google-cloud/pubsub');\n   * const pubsub = new PubSub();\n   *\n   * const topic = pubsub.topic('my-topic');\n   * const subscription = topic.subscription('my-subscription');\n   *\n   * const pushConfig = {\n   *   pushEndpoint: 'https://mydomain.com/push',\n   *   attributes: {\n   *     key: 'value'\n   *   },\n   *   oidcToken: {\n   *     serviceAccountEmail: 'myproject@appspot.gserviceaccount.com',\n   *     audience: 'myaudience'\n   *   }\n   * };\n   *\n   * subscription.modifyPushConfig(pushConfig, (err, apiResponse) => {\n   *   if (err) {\n   *     // Error handling omitted.\n   *   }\n   * });\n   *\n   * //-\n   * // If the callback is omitted, we'll return a Promise.\n   * //-\n   * subscription.modifyPushConfig(pushConfig).then((data) => {\n   *   const apiResponse = data[0];\n   * });\n   */\n\n\n  modifyPushConfig(config, optsOrCallback, callback) {\n    const gaxOpts = typeof optsOrCallback === 'object' ? optsOrCallback : {};\n    callback = typeof optsOrCallback === 'function' ? optsOrCallback : callback;\n    const reqOpts = {\n      subscription: this.name,\n      pushConfig: config\n    };\n    this.request({\n      client: 'SubscriberClient',\n      method: 'modifyPushConfig',\n      reqOpts,\n      gaxOpts\n    }, callback);\n  }\n  /**\n   * Opens the Subscription to receive messages. In general this method\n   * shouldn't need to be called, unless you wish to receive messages after\n   * calling {@link Subscription#close}. Alternatively one could just assign a\n   * new `message` event listener which will also re-open the Subscription.\n   *\n   * @example\n   * subscription.on('message', message => message.ack());\n   *\n   * // Close the subscription.\n   * subscription.close(err => {\n   *   if (err) {\n   *     // Error handling omitted.\n   *   }\n   *\n   *   The subscription has been closed and messages will no longer be received.\n   * });\n   *\n   * // Resume receiving messages.\n   * subscription.open();\n   */\n\n\n  open() {\n    if (!this._subscriber.isOpen) {\n      this._subscriber.open();\n    }\n  }\n  /**\n   * @typedef {array} SeekResponse\n   * @property {object} 0 The full API response.\n   */\n\n  /**\n   * @callback SeekCallback\n   * @param {?Error} err Request error, if any.\n   * @param {object} apiResponse The full API response.\n   */\n\n  /**\n   * Seeks an existing subscription to a point in time or a given snapshot.\n   *\n   * @param {string|date} snapshot The point to seek to. This will accept the\n   *     name of the snapshot or a Date object.\n   * @param {object} [gaxOpts] Request configuration options, outlined\n   *     here: https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html.\n   * @param {SeekCallback} [callback] Callback function.\n   * @returns {Promise<SeekResponse>}\n   *\n   * @example\n   * const callback = (err, resp) => {\n   *   if (!err) {\n   *     // Seek was successful.\n   *   }\n   * };\n   *\n   * subscription.seek('my-snapshot', callback);\n   *\n   * //-\n   * // Alternatively, to specify a certain point in time, you can provide a\n   * Date\n   * // object.\n   * //-\n   * const date = new Date('October 21 2015');\n   *\n   * subscription.seek(date, callback);\n   */\n\n\n  seek(snapshot, optsOrCallback, callback) {\n    const gaxOpts = typeof optsOrCallback === 'object' ? optsOrCallback : {};\n    callback = typeof optsOrCallback === 'function' ? optsOrCallback : callback;\n    const reqOpts = {\n      subscription: this.name\n    };\n\n    if (typeof snapshot === 'string') {\n      reqOpts.snapshot = snapshot_1.Snapshot.formatName_(this.pubsub.projectId, snapshot);\n    } else if (Object.prototype.toString.call(snapshot) === '[object Date]') {\n      const dateMillis = snapshot.getTime();\n      reqOpts.time = {\n        seconds: Math.floor(dateMillis / 1000),\n        nanos: Math.floor(dateMillis % 1000) * 1000\n      };\n    } else {\n      throw new Error('Either a snapshot name or Date is needed to seek to.');\n    }\n\n    this.request({\n      client: 'SubscriberClient',\n      method: 'seek',\n      reqOpts,\n      gaxOpts\n    }, callback);\n  }\n  /**\n   * @typedef {array} SetSubscriptionMetadataResponse\n   * @property {object} 0 The full API response.\n   */\n\n  /**\n   * @callback SetSubscriptionMetadataCallback\n   * @param {?Error} err Request error, if any.\n   * @param {object} apiResponse The full API response.\n   */\n\n  /**\n   * Update the subscription object.\n   *\n   * @param {object} metadata The subscription metadata.\n   * @param {object} [gaxOpts] Request configuration options, outlined\n   *     here: https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html.\n   * @param {SetSubscriptionMetadataCallback} [callback] Callback function.\n   * @returns {Promise<SetSubscriptionMetadataResponse>}\n   *\n   * @example\n   * const metadata = {\n   *   key: 'value'\n   * };\n   *\n   * subscription.setMetadata(metadata, (err, apiResponse) => {\n   *   if (err) {\n   *     // Error handling omitted.\n   *   }\n   * });\n   *\n   * //-\n   * // If the callback is omitted, we'll return a Promise.\n   * //-\n   * subscription.setMetadata(metadata).then((data) => {\n   *   const apiResponse = data[0];\n   * });\n   */\n\n\n  setMetadata(metadata, optsOrCallback, callback) {\n    const gaxOpts = typeof optsOrCallback === 'object' ? optsOrCallback : {};\n    callback = typeof optsOrCallback === 'function' ? optsOrCallback : callback;\n    const subscription = Subscription.formatMetadata_(metadata);\n    const fields = Object.keys(subscription).map(snakeCase);\n    subscription.name = this.name;\n    const reqOpts = {\n      subscription,\n      updateMask: {\n        paths: fields\n      }\n    };\n    this.request({\n      client: 'SubscriberClient',\n      method: 'updateSubscription',\n      reqOpts,\n      gaxOpts\n    }, callback);\n  }\n  /**\n   * Sets the Subscription options.\n   *\n   * @param {SubscriberOptions} options The options.\n   */\n\n\n  setOptions(options) {\n    this._subscriber.setOptions(options);\n  }\n  /**\n   * Create a Snapshot object. See {@link Subscription#createSnapshot} to\n   * create a snapshot.\n   *\n   * @throws {Error} If a name is not provided.\n   *\n   * @param {string} name The name of the snapshot.\n   * @returns {Snapshot}\n   *\n   * @example\n   * const snapshot = subscription.snapshot('my-snapshot');\n   */\n\n\n  snapshot(name) {\n    return this.pubsub.snapshot.call(this, name);\n  }\n  /**\n   * Watches for incoming message event handlers and open/closes the\n   * subscriber as needed.\n   *\n   * @private\n   */\n\n\n  _listen() {\n    this.on('newListener', event => {\n      if (!this.isOpen && event === 'message') {\n        this._subscriber.open();\n      }\n    });\n    this.on('removeListener', () => {\n      if (this.isOpen && this.listenerCount('message') === 0) {\n        this._subscriber.close();\n      }\n    });\n  }\n  /*!\n   * Formats Subscription metadata.\n   *\n   * @private\n   */\n\n\n  static formatMetadata_(metadata) {\n    const formatted = extend(true, {}, metadata);\n\n    if (typeof metadata.messageRetentionDuration === 'number') {\n      formatted.messageRetentionDuration = {\n        seconds: metadata.messageRetentionDuration,\n        nanos: 0\n      };\n    }\n\n    if (metadata.pushEndpoint) {\n      formatted.pushConfig = {\n        pushEndpoint: metadata.pushEndpoint\n      };\n      delete formatted.pushEndpoint;\n    }\n\n    if (metadata.oidcToken) {\n      formatted.pushConfig = { ...formatted.pushConfig,\n        oidcToken: metadata.oidcToken\n      };\n      delete formatted.oidcToken;\n    }\n\n    return formatted;\n  }\n  /*!\n   * Format the name of a subscription. A subscription's full name is in the\n   * format of projects/{projectId}/subscriptions/{subName}.\n   *\n   * @private\n   */\n\n\n  static formatName_(projectId, name) {\n    // Simple check if the name is already formatted.\n    if (name.indexOf('/') > -1) {\n      return name;\n    }\n\n    return 'projects/' + projectId + '/subscriptions/' + name;\n  }\n\n}\n\nexports.Subscription = Subscription;\n/*! Developer Documentation\n *\n * All async methods (except for streams) will return a Promise in the event\n * that a callback is omitted.\n */\n\npromisify_1.promisifyAll(Subscription, {\n  exclude: ['open', 'snapshot']\n});","map":{"version":3,"sources":["../../src/subscription.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Subscription = void 0;\nconst promisify_1 = require(\"@google-cloud/promisify\");\nconst events_1 = require(\"events\");\nconst extend = require(\"extend\");\nconst snakeCase = require(\"lodash.snakecase\");\nconst iam_1 = require(\"./iam\");\nconst snapshot_1 = require(\"./snapshot\");\nconst subscriber_1 = require(\"./subscriber\");\n// JSDoc won't see these, so this is just to let you get typings\n// in your editor of choice.\n//\n// NOTE: These are commented out for now because we don't want to\n// break any existing clients that rely on not-entirely-correct\n// typings. We'll re-enable on the next major.\n/* export declare interface Subscription {\n  on(\n    event: 'message',\n    listener: (message: Message) => void\n  ): this;\n  on(\n    event: 'error',\n    listener: (error: StatusError) => void\n  ): this;\n  on(event: 'close', listener: () => void): this;\n\n  // Only used internally.\n  on(event: 'newListener', listener: Function): this;\n  on(event: 'removeListener', listener: Function): this;\n\n  // Catch-all. If you get an error about this line, it means you're\n  // using an unsupported event type or listener type.\n  on(event: string, listener: void): this;\n} */\n/**\n * @typedef {object} ExpirationPolicy\n * A policy that specifies the conditions for this subscription's expiration. A\n * subscription is considered active as long as any connected subscriber is\n * successfully consuming messages from the subscription or is issuing\n * operations on the subscription. If expirationPolicy is not set, a default\n * policy with ttl of 31 days will be used. The minimum allowed value for\n * expirationPolicy.ttl is 1 day.\n * @property {google.protobuf.Duration} ttl Specifies the \"time-to-live\"\n *     duration for an associated resource. The resource expires if it is not\n *     active for a period of `ttl`. The definition of \"activity\" depends on the\n *     type of the associated resource. The minimum and maximum allowed values\n *     for `ttl` depend on the type of the associated resource, as well. If\n *     `ttl` is not set, the associated resource never expires.\n */\n/**\n * A Subscription object will give you access to your Cloud Pub/Sub\n * subscription.\n *\n * Subscriptions are sometimes retrieved when using various methods:\n *\n * - {@link PubSub#getSubscriptions}\n * - {@link Topic#getSubscriptions}\n *\n * Subscription objects may be created directly with:\n *\n * - {@link PubSub#createSubscription}\n * - {@link Topic#createSubscription}\n *\n * All Subscription objects are instances of an\n * [EventEmitter](http://nodejs.org/api/events.html). The subscription will pull\n * for messages automatically as long as there is at least one listener assigned\n * for the `message` event. Available events:\n *\n * Upon receipt of a message:\n * on(event: 'message', listener: (message: {@link Message}) => void): this;\n *\n * Upon receipt of an error:\n * on(event: 'error', listener: (error: Error) => void): this;\n *\n * Upon the closing of the subscriber:\n * on(event: 'close', listener: Function): this;\n *\n * By default Subscription objects allow you to process 100 messages at the same\n * time. You can fine tune this value by adjusting the\n * `options.flowControl.maxMessages` option.\n *\n * If your subscription is seeing more re-deliveries than preferable, you might\n * try increasing your `options.ackDeadline` value or decreasing the\n * `options.streamingOptions.maxStreams` value.\n *\n * Subscription objects handle ack management, by automatically extending the\n * ack deadline while the message is being processed, to then issue the ack or\n * nack of such message when the processing is done. **Note:** message\n * redelivery is still possible.\n *\n * By default each {@link PubSub} instance can handle 100 open streams, with\n * default options this translates to less than 20 Subscriptions per PubSub\n * instance. If you wish to create more Subscriptions than that, you can either\n * create multiple PubSub instances or lower the\n * `options.streamingOptions.maxStreams` value on each Subscription object.\n *\n * @class\n *\n * @param {PubSub} pubsub PubSub object.\n * @param {string} name The name of the subscription.\n * @param {SubscriberOptions} [options] Options for handling messages.\n *\n * @example <caption>From {@link PubSub#getSubscriptions}</caption>\n * const {PubSub} = require('@google-cloud/pubsub');\n * const pubsub = new PubSub();\n *\n * pubsub.getSubscriptions((err, subscriptions) => {\n *   // `subscriptions` is an array of Subscription objects.\n * });\n *\n * @example <caption>From {@link Topic#getSubscriptions}</caption>\n * const topic = pubsub.topic('my-topic');\n * topic.getSubscriptions((err, subscriptions) => {\n *   // `subscriptions` is an array of Subscription objects.\n * });\n *\n * @example <caption>{@link Topic#createSubscription}</caption>\n * const topic = pubsub.topic('my-topic');\n * topic.createSubscription('new-subscription', (err, subscription) => {\n *   // `subscription` is a Subscription object.\n * });\n *\n * @example <caption>{@link Topic#subscription}</caption>\n * const topic = pubsub.topic('my-topic');\n * const subscription = topic.subscription('my-subscription');\n * // `subscription` is a Subscription object.\n *\n * @example <caption>Once you have obtained a subscription object, you may begin\n * to register listeners. This will automatically trigger pulling for messages.\n * </caption>\n * // Register an error handler.\n * subscription.on('error', (err) => {});\n *\n * // Register a close handler in case the subscriber closes unexpectedly\n * subscription.on('close', () => {});\n *\n * // Register a listener for `message` events.\n * function onMessage(message) {\n *   // Called every time a message is received.\n *\n *   // message.id = ID of the message.\n *   // message.ackId = ID used to acknowledge the message receival.\n *   // message.data = Contents of the message.\n *   // message.attributes = Attributes of the message.\n *   // message.publishTime = Date when Pub/Sub received the message.\n *\n *   // Ack the message:\n *   // message.ack();\n *\n *   // This doesn't ack the message, but allows more messages to be retrieved\n *   // if your limit was hit or if you don't want to ack the message.\n *   // message.nack();\n * }\n * subscription.on('message', onMessage);\n *\n * // Remove the listener from receiving `message` events.\n * subscription.removeListener('message', onMessage);\n *\n * @example <caption>To apply a fine level of flow control, consider the\n * following configuration</caption>\n * const subscription = topic.subscription('my-sub', {\n *   flowControl: {\n *     maxMessages: 1,\n *     // this tells the client to manage and lock any excess messages\n *     allowExcessMessages: false\n *   }\n * });\n */\nclass Subscription extends events_1.EventEmitter {\n    constructor(pubsub, name, options) {\n        super();\n        options = options || {};\n        this.pubsub = pubsub;\n        this.request = pubsub.request.bind(pubsub);\n        this.name = Subscription.formatName_(this.projectId, name);\n        this.topic = options.topic;\n        /**\n         * [IAM (Identity and Access\n         * Management)](https://cloud.google.com/pubsub/access_control) allows you\n         * to set permissions on individual resources and offers a wider range of\n         * roles: editor, owner, publisher, subscriber, and viewer. This gives you\n         * greater flexibility and allows you to set more fine-grained access\n         * control.\n         *\n         * *The IAM access control features described in this document are Beta,\n         * including the API methods to get and set IAM policies, and to test IAM\n         * permissions. Cloud Pub/Sub's use of IAM features is not covered by\n         * any SLA or deprecation policy, and may be subject to\n         * backward-incompatible changes.*\n         *\n         * @name Subscription#iam\n         * @mixes IAM\n         *\n         * @see [Access Control Overview]{@link https://cloud.google.com/pubsub/access_control}\n         * @see [What is Cloud IAM?]{@link https://cloud.google.com/iam/}\n         *\n         * @example\n         * //-\n         * // Get the IAM policy for your subscription.\n         * //-\n         * subscription.iam.getPolicy((err, policy) => {\n         *   console.log(policy);\n         * });\n         *\n         * //-\n         * // If the callback is omitted, we'll return a Promise.\n         * //-\n         * subscription.iam.getPolicy().then((data) => {\n         *   const policy = data[0];\n         *   const apiResponse = data[1];\n         * });\n         */\n        this.iam = new iam_1.IAM(pubsub, this.name);\n        this._subscriber = new subscriber_1.Subscriber(this, options);\n        this._subscriber\n            .on('error', err => this.emit('error', err))\n            .on('message', message => this.emit('message', message))\n            .on('close', () => this.emit('close'));\n        this._listen();\n    }\n    /**\n     * Indicates if the Subscription is open and receiving messages.\n     *\n     * @type {boolean}\n     */\n    get isOpen() {\n        return !!(this._subscriber && this._subscriber.isOpen);\n    }\n    /**\n     * @type {string}\n     */\n    get projectId() {\n        return (this.pubsub && this.pubsub.projectId) || '{{projectId}}';\n    }\n    /**\n     * Closes the Subscription, once this is called you will no longer receive\n     * message events unless you call {Subscription#open} or add new message\n     * listeners.\n     *\n     * @param {function} [callback] The callback function.\n     * @param {?error} callback.err An error returned while closing the\n     *     Subscription.\n     *\n     * @example\n     * subscription.close(err => {\n     *   if (err) {\n     *     // Error handling omitted.\n     *   }\n     * });\n     *\n     * // If the callback is omitted a Promise will be returned.\n     * subscription.close().then(() => {});\n     */\n    close(callback) {\n        this._subscriber.close().then(() => callback(), callback);\n    }\n    /**\n     * Create a subscription.\n     *\n     * @see [Subscriptions: create API Documentation]{@link https://cloud.google.com/pubsub/docs/reference/rest/v1/projects.subscriptions/create}\n     *\n     * @throws {Error} If subscription name is omitted.\n     *\n     * @param {string} name The name of the subscription.\n     * @param {CreateSubscriptionRequest} [options] See a\n     *     [Subscription\n     * resource](https://cloud.google.com/pubsub/docs/reference/rest/v1/projects.subscriptions).\n     * @param {CreateSubscriptionCallback} [callback] Callback function.\n     * @returns {Promise<CreateSubscriptionResponse>}\n     *\n     * @example\n     * const {PubSub} = require('@google-cloud/pubsub');\n     * const pubsub = new PubSub();\n     *\n     * const topic = pubsub.topic('my-topic');\n     * const subscription = topic.subscription('newMessages');\n     * const callback = function(err, subscription, apiResponse) {};\n     *\n     * subscription.create(callback);\n     *\n     * @example <caption>With options</caption>\n     * subscription.create({\n     *   ackDeadlineSeconds: 90\n     * }, callback);\n     *\n     * @example <caption>If the callback is omitted, we'll return a\n     * Promise.</caption> const [sub, apiResponse] = await subscription.create();\n     */\n    create(optsOrCallback, callback) {\n        if (!this.topic) {\n            throw new Error('Subscriptions can only be created when accessed through Topics');\n        }\n        const name = this.name.split('/').pop();\n        const options = typeof optsOrCallback === 'object' ? optsOrCallback : {};\n        callback = typeof optsOrCallback === 'function' ? optsOrCallback : callback;\n        this.pubsub.createSubscription(this.topic, name, options, (err, sub, resp) => {\n            if (err) {\n                callback(err, null, resp);\n                return;\n            }\n            Object.assign(this, sub);\n            callback(null, this, resp);\n        });\n    }\n    /**\n     * @typedef {array} CreateSnapshotResponse\n     * @property {Snapshot} 0 The new {@link Snapshot}.\n     * @property {object} 1 The full API response.\n     */\n    /**\n     * @callback CreateSnapshotCallback\n     * @param {?Error} err Request error, if any.\n     * @param {Snapshot} snapshot The new {@link Snapshot}.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * Create a snapshot with the given name.\n     *\n     * @param {string} name Name of the snapshot.\n     * @param {object} [gaxOpts] Request configuration options, outlined\n     *     here: https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html.\n     * @param {CreateSnapshotCallback} [callback] Callback function.\n     * @returns {Promise<CreateSnapshotResponse>}\n     *\n     * @example\n     * const {PubSub} = require('@google-cloud/pubsub');\n     * const pubsub = new PubSub();\n     *\n     * const topic = pubsub.topic('my-topic');\n     * const subscription = topic.subscription('my-subscription');\n     *\n     * const callback = (err, snapshot, apiResponse) => {\n     *   if (!err) {\n     *     // The snapshot was created successfully.\n     *   }\n     * };\n     *\n     * subscription.createSnapshot('my-snapshot', callback);\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * subscription.createSnapshot('my-snapshot').then((data) => {\n     *   const snapshot = data[0];\n     *   const apiResponse = data[1];\n     * });\n     */\n    createSnapshot(name, optsOrCallback, callback) {\n        if (typeof name !== 'string') {\n            throw new Error('A name is required to create a snapshot.');\n        }\n        const gaxOpts = typeof optsOrCallback === 'object' ? optsOrCallback : {};\n        callback = typeof optsOrCallback === 'function' ? optsOrCallback : callback;\n        const snapshot = this.snapshot(name);\n        const reqOpts = {\n            name: snapshot.name,\n            subscription: this.name,\n        };\n        this.request({\n            client: 'SubscriberClient',\n            method: 'createSnapshot',\n            reqOpts,\n            gaxOpts,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, resp);\n                return;\n            }\n            snapshot.metadata = resp;\n            callback(null, snapshot, resp);\n        });\n    }\n    /**\n     * Delete the subscription. Pull requests from the current subscription will\n     * be errored once unsubscription is complete.\n     *\n     * @see [Subscriptions: delete API Documentation]{@link https://cloud.google.com/pubsub/docs/reference/rest/v1/projects.subscriptions/delete}\n     *\n     * @param {object} [gaxOpts] Request configuration options, outlined\n     *     here: https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html.\n     * @param {function} [callback] The callback function.\n     * @param {?error} callback.err An error returned while making this\n     *     request.\n     * @param {object} callback.apiResponse Raw API response.\n     *\n     * @example\n     * const {PubSub} = require('@google-cloud/pubsub');\n     * const pubsub = new PubSub();\n     *\n     * const topic = pubsub.topic('my-topic');\n     * const subscription = topic.subscription('my-subscription');\n     *\n     * subscription.delete((err, apiResponse) => {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * subscription.delete().then((data) => {\n     *   const apiResponse = data[0];\n     * });\n     */\n    delete(optsOrCallback, callback) {\n        const gaxOpts = typeof optsOrCallback === 'object' ? optsOrCallback : {};\n        callback = typeof optsOrCallback === 'function' ? optsOrCallback : callback;\n        const reqOpts = {\n            subscription: this.name,\n        };\n        if (this.isOpen) {\n            this._subscriber.close();\n        }\n        this.request({\n            client: 'SubscriberClient',\n            method: 'deleteSubscription',\n            reqOpts,\n            gaxOpts,\n        }, callback);\n    }\n    /**\n     * @typedef {array} SubscriptionDetachedResponse\n     * @property {boolean} 0 Whether the subscription is detached.\n     */\n    /**\n     * @callback SubscriptionDetachedCallback\n     * @param {?Error} err Request error, if any.\n     * @param {boolean} exists Whether the subscription is detached.\n     */\n    /**\n     * Check if a subscription is detached.\n     *\n     * @param {SubscriptionDetachedCallback} [callback] Callback function.\n     * @returns {Promise<SubscriptionDetachedResponse>}\n     *\n     * @example\n     * const {PubSub} = require('@google-cloud/pubsub');\n     * const pubsub = new PubSub();\n     *\n     * const topic = pubsub.topic('my-topic');\n     * const subscription = topic.subscription('my-subscription');\n     *\n     * subscription.detached((err, exists) => {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * subscription.detached().then((data) => {\n     *   const detached = data[0];\n     * });\n     */\n    detached(callback) {\n        this.getMetadata((err, metadata) => {\n            if (err) {\n                callback(err);\n            }\n            else {\n                callback(null, metadata.detached);\n            }\n        });\n    }\n    /**\n     * @typedef {array} SubscriptionExistsResponse\n     * @property {boolean} 0 Whether the subscription exists\n     */\n    /**\n     * @callback SubscriptionExistsCallback\n     * @param {?Error} err Request error, if any.\n     * @param {boolean} exists Whether the subscription exists.\n     */\n    /**\n     * Check if a subscription exists.\n     *\n     * @param {SubscriptionExistsCallback} [callback] Callback function.\n     * @returns {Promise<SubscriptionExistsResponse>}\n     *\n     * @example\n     * const {PubSub} = require('@google-cloud/pubsub');\n     * const pubsub = new PubSub();\n     *\n     * const topic = pubsub.topic('my-topic');\n     * const subscription = topic.subscription('my-subscription');\n     *\n     * subscription.exists((err, exists) => {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * subscription.exists().then((data) => {\n     *   const exists = data[0];\n     * });\n     */\n    exists(callback) {\n        this.getMetadata(err => {\n            if (!err) {\n                callback(null, true);\n                return;\n            }\n            if (err.code === 5) {\n                callback(null, false);\n                return;\n            }\n            callback(err);\n        });\n    }\n    /**\n     * @typedef {array} GetSubscriptionResponse\n     * @property {Subscription} 0 The {@link Subscription}.\n     * @property {object} 1 The full API response.\n     */\n    /**\n     * @callback GetSubscriptionCallback\n     * @param {?Error} err Request error, if any.\n     * @param {Subscription} subscription The {@link Subscription}.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * Get a subscription if it exists.\n     *\n     * @param {object} [gaxOpts] Request configuration options, outlined\n     *     here: https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html.\n     * @param {boolean} [gaxOpts.autoCreate=false] Automatically create the\n     *     subscription if it does not already exist.\n     * @param {GetSubscriptionCallback} [callback] Callback function.\n     * @returns {Promise<GetSubscriptionResponse>}\n     *\n     * @example\n     * const {PubSub} = require('@google-cloud/pubsub');\n     * const pubsub = new PubSub();\n     *\n     * const topic = pubsub.topic('my-topic');\n     * const subscription = topic.subscription('my-subscription');\n     *\n     * subscription.get((err, subscription, apiResponse) => {\n     *   // The `subscription` data has been populated.\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * subscription.get().then((data) => {\n     *   const subscription = data[0];\n     *   const apiResponse = data[1];\n     * });\n     */\n    get(optsOrCallback, callback) {\n        const gaxOpts = typeof optsOrCallback === 'object' ? optsOrCallback : {};\n        callback = typeof optsOrCallback === 'function' ? optsOrCallback : callback;\n        const autoCreate = !!gaxOpts.autoCreate && this.topic;\n        delete gaxOpts.autoCreate;\n        this.getMetadata(gaxOpts, (err, apiResponse) => {\n            if (!err) {\n                callback(null, this, apiResponse);\n                return;\n            }\n            if (err.code !== 5 || !autoCreate) {\n                callback(err, null, apiResponse);\n                return;\n            }\n            this.create({ gaxOpts }, callback);\n        });\n    }\n    /**\n     * @typedef {array} GetSubscriptionMetadataResponse\n     * @property {object} 0 The full API response.\n     */\n    /**\n     * @callback GetSubscriptionMetadataCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * Fetches the subscriptions metadata.\n     *\n     * @param {object} [gaxOpts] Request configuration options, outlined\n     *     here: https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html.\n     * @param {GetSubscriptionMetadataCallback} [callback] Callback function.\n     * @returns {Promise<GetSubscriptionMetadataResponse>}\n     *\n     * @example\n     * const {PubSub} = require('@google-cloud/pubsub');\n     * const pubsub = new PubSub();\n     *\n     * const topic = pubsub.topic('my-topic');\n     * const subscription = topic.subscription('my-subscription');\n     *\n     * subscription.getMetadata((err, apiResponse) => {\n     *   if (err) {\n     *     // Error handling omitted.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * subscription.getMetadata().then((data) => {\n     *   const apiResponse = data[0];\n     * });\n     */\n    getMetadata(optsOrCallback, callback) {\n        const gaxOpts = typeof optsOrCallback === 'object' ? optsOrCallback : {};\n        callback = typeof optsOrCallback === 'function' ? optsOrCallback : callback;\n        const reqOpts = {\n            subscription: this.name,\n        };\n        this.request({\n            client: 'SubscriberClient',\n            method: 'getSubscription',\n            reqOpts,\n            gaxOpts,\n        }, (err, apiResponse) => {\n            if (!err) {\n                this.metadata = apiResponse;\n            }\n            callback(err, apiResponse);\n        });\n    }\n    /**\n     * @typedef {array} ModifyPushConfigResponse\n     * @property {object} 0 The full API response.\n     */\n    /**\n     * @callback ModifyPushConfigCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * Modify the push config for the subscription.\n     *\n     * @param {object} config The push config.\n     * @param {string} config.pushEndpoint A URL locating the endpoint to which\n     *     messages should be published.\n     * @param {object} config.attributes [PushConfig attributes](https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#google.pubsub.v1.PushConfig).\n     * @param {object} config.oidcToken If specified, Pub/Sub will generate and\n     *     attach an OIDC JWT token as an `Authorization` header in the HTTP\n     *     request for every pushed message. This object should have the same\n     *     structure as [OidcToken]{@link google.pubsub.v1.OidcToken}\n     * @param {object} [gaxOpts] Request configuration options, outlined\n     *     here: https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html.\n     * @param {ModifyPushConfigCallback} [callback] Callback function.\n     * @returns {Promise<ModifyPushConfigResponse>}\n     *\n     * @example\n     * const {PubSub} = require('@google-cloud/pubsub');\n     * const pubsub = new PubSub();\n     *\n     * const topic = pubsub.topic('my-topic');\n     * const subscription = topic.subscription('my-subscription');\n     *\n     * const pushConfig = {\n     *   pushEndpoint: 'https://mydomain.com/push',\n     *   attributes: {\n     *     key: 'value'\n     *   },\n     *   oidcToken: {\n     *     serviceAccountEmail: 'myproject@appspot.gserviceaccount.com',\n     *     audience: 'myaudience'\n     *   }\n     * };\n     *\n     * subscription.modifyPushConfig(pushConfig, (err, apiResponse) => {\n     *   if (err) {\n     *     // Error handling omitted.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * subscription.modifyPushConfig(pushConfig).then((data) => {\n     *   const apiResponse = data[0];\n     * });\n     */\n    modifyPushConfig(config, optsOrCallback, callback) {\n        const gaxOpts = typeof optsOrCallback === 'object' ? optsOrCallback : {};\n        callback = typeof optsOrCallback === 'function' ? optsOrCallback : callback;\n        const reqOpts = {\n            subscription: this.name,\n            pushConfig: config,\n        };\n        this.request({\n            client: 'SubscriberClient',\n            method: 'modifyPushConfig',\n            reqOpts,\n            gaxOpts,\n        }, callback);\n    }\n    /**\n     * Opens the Subscription to receive messages. In general this method\n     * shouldn't need to be called, unless you wish to receive messages after\n     * calling {@link Subscription#close}. Alternatively one could just assign a\n     * new `message` event listener which will also re-open the Subscription.\n     *\n     * @example\n     * subscription.on('message', message => message.ack());\n     *\n     * // Close the subscription.\n     * subscription.close(err => {\n     *   if (err) {\n     *     // Error handling omitted.\n     *   }\n     *\n     *   The subscription has been closed and messages will no longer be received.\n     * });\n     *\n     * // Resume receiving messages.\n     * subscription.open();\n     */\n    open() {\n        if (!this._subscriber.isOpen) {\n            this._subscriber.open();\n        }\n    }\n    /**\n     * @typedef {array} SeekResponse\n     * @property {object} 0 The full API response.\n     */\n    /**\n     * @callback SeekCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * Seeks an existing subscription to a point in time or a given snapshot.\n     *\n     * @param {string|date} snapshot The point to seek to. This will accept the\n     *     name of the snapshot or a Date object.\n     * @param {object} [gaxOpts] Request configuration options, outlined\n     *     here: https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html.\n     * @param {SeekCallback} [callback] Callback function.\n     * @returns {Promise<SeekResponse>}\n     *\n     * @example\n     * const callback = (err, resp) => {\n     *   if (!err) {\n     *     // Seek was successful.\n     *   }\n     * };\n     *\n     * subscription.seek('my-snapshot', callback);\n     *\n     * //-\n     * // Alternatively, to specify a certain point in time, you can provide a\n     * Date\n     * // object.\n     * //-\n     * const date = new Date('October 21 2015');\n     *\n     * subscription.seek(date, callback);\n     */\n    seek(snapshot, optsOrCallback, callback) {\n        const gaxOpts = typeof optsOrCallback === 'object' ? optsOrCallback : {};\n        callback = typeof optsOrCallback === 'function' ? optsOrCallback : callback;\n        const reqOpts = {\n            subscription: this.name,\n        };\n        if (typeof snapshot === 'string') {\n            reqOpts.snapshot = snapshot_1.Snapshot.formatName_(this.pubsub.projectId, snapshot);\n        }\n        else if (Object.prototype.toString.call(snapshot) === '[object Date]') {\n            const dateMillis = snapshot.getTime();\n            reqOpts.time = {\n                seconds: Math.floor(dateMillis / 1000),\n                nanos: Math.floor(dateMillis % 1000) * 1000,\n            };\n        }\n        else {\n            throw new Error('Either a snapshot name or Date is needed to seek to.');\n        }\n        this.request({\n            client: 'SubscriberClient',\n            method: 'seek',\n            reqOpts,\n            gaxOpts,\n        }, callback);\n    }\n    /**\n     * @typedef {array} SetSubscriptionMetadataResponse\n     * @property {object} 0 The full API response.\n     */\n    /**\n     * @callback SetSubscriptionMetadataCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * Update the subscription object.\n     *\n     * @param {object} metadata The subscription metadata.\n     * @param {object} [gaxOpts] Request configuration options, outlined\n     *     here: https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html.\n     * @param {SetSubscriptionMetadataCallback} [callback] Callback function.\n     * @returns {Promise<SetSubscriptionMetadataResponse>}\n     *\n     * @example\n     * const metadata = {\n     *   key: 'value'\n     * };\n     *\n     * subscription.setMetadata(metadata, (err, apiResponse) => {\n     *   if (err) {\n     *     // Error handling omitted.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * subscription.setMetadata(metadata).then((data) => {\n     *   const apiResponse = data[0];\n     * });\n     */\n    setMetadata(metadata, optsOrCallback, callback) {\n        const gaxOpts = typeof optsOrCallback === 'object' ? optsOrCallback : {};\n        callback = typeof optsOrCallback === 'function' ? optsOrCallback : callback;\n        const subscription = Subscription.formatMetadata_(metadata);\n        const fields = Object.keys(subscription).map(snakeCase);\n        subscription.name = this.name;\n        const reqOpts = {\n            subscription,\n            updateMask: {\n                paths: fields,\n            },\n        };\n        this.request({\n            client: 'SubscriberClient',\n            method: 'updateSubscription',\n            reqOpts,\n            gaxOpts,\n        }, callback);\n    }\n    /**\n     * Sets the Subscription options.\n     *\n     * @param {SubscriberOptions} options The options.\n     */\n    setOptions(options) {\n        this._subscriber.setOptions(options);\n    }\n    /**\n     * Create a Snapshot object. See {@link Subscription#createSnapshot} to\n     * create a snapshot.\n     *\n     * @throws {Error} If a name is not provided.\n     *\n     * @param {string} name The name of the snapshot.\n     * @returns {Snapshot}\n     *\n     * @example\n     * const snapshot = subscription.snapshot('my-snapshot');\n     */\n    snapshot(name) {\n        return this.pubsub.snapshot.call(this, name);\n    }\n    /**\n     * Watches for incoming message event handlers and open/closes the\n     * subscriber as needed.\n     *\n     * @private\n     */\n    _listen() {\n        this.on('newListener', event => {\n            if (!this.isOpen && event === 'message') {\n                this._subscriber.open();\n            }\n        });\n        this.on('removeListener', () => {\n            if (this.isOpen && this.listenerCount('message') === 0) {\n                this._subscriber.close();\n            }\n        });\n    }\n    /*!\n     * Formats Subscription metadata.\n     *\n     * @private\n     */\n    static formatMetadata_(metadata) {\n        const formatted = extend(true, {}, metadata);\n        if (typeof metadata.messageRetentionDuration === 'number') {\n            formatted.messageRetentionDuration = {\n                seconds: metadata.messageRetentionDuration,\n                nanos: 0,\n            };\n        }\n        if (metadata.pushEndpoint) {\n            formatted.pushConfig = {\n                pushEndpoint: metadata.pushEndpoint,\n            };\n            delete formatted.pushEndpoint;\n        }\n        if (metadata.oidcToken) {\n            formatted.pushConfig = {\n                ...formatted.pushConfig,\n                oidcToken: metadata.oidcToken,\n            };\n            delete formatted.oidcToken;\n        }\n        return formatted;\n    }\n    /*!\n     * Format the name of a subscription. A subscription's full name is in the\n     * format of projects/{projectId}/subscriptions/{subName}.\n     *\n     * @private\n     */\n    static formatName_(projectId, name) {\n        // Simple check if the name is already formatted.\n        if (name.indexOf('/') > -1) {\n            return name;\n        }\n        return 'projects/' + projectId + '/subscriptions/' + name;\n    }\n}\nexports.Subscription = Subscription;\n/*! Developer Documentation\n *\n * All async methods (except for streams) will return a Promise in the event\n * that a callback is omitted.\n */\npromisify_1.promisifyAll(Subscription, {\n    exclude: ['open', 'snapshot'],\n});\n//# sourceMappingURL=subscription.js.map"]},"metadata":{},"sourceType":"script"}