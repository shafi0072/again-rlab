{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subscriber = exports.Message = void 0;\n\nconst precise_date_1 = require(\"@google-cloud/precise-date\");\n\nconst projectify_1 = require(\"@google-cloud/projectify\");\n\nconst promisify_1 = require(\"@google-cloud/promisify\");\n\nconst events_1 = require(\"events\");\n\nconst api_1 = require(\"@opentelemetry/api\");\n\nconst semantic_conventions_1 = require(\"@opentelemetry/semantic-conventions\");\n\nconst histogram_1 = require(\"./histogram\");\n\nconst lease_manager_1 = require(\"./lease-manager\");\n\nconst message_queues_1 = require(\"./message-queues\");\n\nconst message_stream_1 = require(\"./message-stream\");\n\nconst default_options_1 = require(\"./default-options\");\n\nconst opentelemetry_tracing_1 = require(\"./opentelemetry-tracing\");\n/**\n * Date object with nanosecond precision. Supports all standard Date arguments\n * in addition to several custom types.\n *\n * @external PreciseDate\n * @see {@link https://github.com/googleapis/nodejs-precise-date|PreciseDate}\n */\n\n/**\n * Message objects provide a simple interface for users to get message data and\n * acknowledge the message.\n *\n * @example\n * subscription.on('message', message => {\n *   // {\n *   //   ackId: 'RUFeQBJMJAxESVMrQwsqWBFOBCEhPjA',\n *   //   attributes: {key: 'value'},\n *   //   data: Buffer.from('Hello, world!'),\n *   //   id: '1551297743043',\n *   //   orderingKey: 'ordering-key',\n *   //   publishTime: new PreciseDate('2019-02-27T20:02:19.029534186Z'),\n *   //   received: 1551297743043,\n *   //   length: 13\n *   // }\n * });\n */\n\n\nclass Message {\n  /**\n   * @hideconstructor\n   *\n   * @param {Subscriber} sub The parent subscriber.\n   * @param {object} message The raw message response.\n   */\n  constructor(sub, {\n    ackId,\n    message,\n    deliveryAttempt\n  }) {\n    /**\n     * This ID is used to acknowledge the message.\n     *\n     * @name Message#ackId\n     * @type {string}\n     */\n    this.ackId = ackId;\n    /**\n     * Optional attributes for this message.\n     *\n     * @name Message#attributes\n     * @type {object}\n     */\n\n    this.attributes = message.attributes || {};\n    /**\n     * The message data as a Buffer.\n     *\n     * @name Message#data\n     * @type {Buffer}\n     */\n\n    this.data = message.data;\n    /**\n     * Delivery attempt counter is 1 + (the sum of number of NACKs and number of\n     * ack_deadline exceeds) for this message.\n     *\n     * @name Message#deliveryAttempt\n     * @type {number}\n     */\n\n    this.deliveryAttempt = Number(deliveryAttempt || 0);\n    /**\n     * ID of the message, assigned by the server when the message is published.\n     * Guaranteed to be unique within the topic.\n     *\n     * @name Message#id\n     * @type {string}\n     */\n\n    this.id = message.messageId;\n    /**\n     * Identifies related messages for which publish order should be respected.\n     * If a `Subscription` has `enableMessageOrdering` set to `true`, messages\n     * published with the same `orderingKey` value will be delivered to\n     * subscribers in the order in which they are received by the Pub/Sub\n     * system.\n     *\n     * **EXPERIMENTAL:** This feature is part of a closed alpha release. This\n     * API might be changed in backward-incompatible ways and is not recommended\n     * for production use. It is not subject to any SLA or deprecation policy.\n     *\n     * @name Message#orderingKey\n     * @type {string}\n     */\n\n    this.orderingKey = message.orderingKey;\n    /**\n     * The time at which the message was published.\n     *\n     * @name Message#publishTime\n     * @type {external:PreciseDate}\n     */\n\n    this.publishTime = new precise_date_1.PreciseDate(message.publishTime);\n    /**\n     * The time at which the message was recieved by the subscription.\n     *\n     * @name Message#received\n     * @type {number}\n     */\n\n    this.received = Date.now();\n    this._handled = false;\n    this._length = this.data.length;\n    this._subscriber = sub;\n  }\n  /**\n   * The length of the message data.\n   *\n   * @type {number}\n   */\n\n\n  get length() {\n    return this._length;\n  }\n  /**\n   * Acknowledges the message.\n   *\n   * @example\n   * subscription.on('message', message => {\n   *   message.ack();\n   * });\n   */\n\n\n  ack() {\n    if (!this._handled) {\n      this._handled = true;\n\n      this._subscriber.ack(this);\n    }\n  }\n  /**\n   * Modifies the ack deadline.\n   *\n   * @param {number} deadline The number of seconds to extend the deadline.\n   * @private\n   */\n\n\n  modAck(deadline) {\n    if (!this._handled) {\n      this._subscriber.modAck(this, deadline);\n    }\n  }\n  /**\n   * Removes the message from our inventory and schedules it to be redelivered.\n   *\n   * @example\n   * subscription.on('message', message => {\n   *   message.nack();\n   * });\n   */\n\n\n  nack() {\n    if (!this._handled) {\n      this._handled = true;\n\n      this._subscriber.nack(this);\n    }\n  }\n\n}\n\nexports.Message = Message;\n/**\n * @typedef {object} SubscriberOptions\n * @property {number} [ackDeadline=10] Acknowledge deadline in seconds. If left\n *     unset the initial value will be 10 seconds, but it will evolve into the\n *     99th percentile time it takes to acknowledge a message.\n * @property {BatchOptions} [batching] Request batching options.\n * @property {FlowControlOptions} [flowControl] Flow control options.\n * @property {boolean} [useLegacyFlowControl] Disables enforcing flow control\n *     settings at the Cloud PubSub server and uses the less accurate method\n *     of only enforcing flow control at the client side.\n * @property {MessageStreamOptions} [streamingOptions] Streaming options.\n */\n\n/**\n * Subscriber class is used to manage all message related functionality.\n *\n * @private\n * @class\n *\n * @param {Subscription} subscription The corresponding subscription.\n * @param {SubscriberOptions} options The subscriber options.\n */\n\nclass Subscriber extends events_1.EventEmitter {\n  constructor(subscription, options = {}) {\n    super();\n    this.ackDeadline = 10;\n    this.maxMessages = default_options_1.defaultOptions.subscription.maxOutstandingMessages;\n    this.maxBytes = default_options_1.defaultOptions.subscription.maxOutstandingBytes;\n    this.useLegacyFlowControl = false;\n    this.isOpen = false;\n    this._isUserSetDeadline = false;\n    this._useOpentelemetry = false;\n    this._histogram = new histogram_1.Histogram({\n      min: 10,\n      max: 600\n    });\n    this._latencies = new histogram_1.Histogram();\n    this._subscription = subscription;\n    this.setOptions(options);\n  }\n  /**\n   * The 99th percentile of request latencies.\n   *\n   * @type {number}\n   * @private\n   */\n\n\n  get modAckLatency() {\n    const latency = this._latencies.percentile(99);\n\n    let bufferTime = 0;\n\n    if (this._modAcks) {\n      bufferTime = this._modAcks.maxMilliseconds;\n    }\n\n    return latency * 1000 + bufferTime;\n  }\n  /**\n   * The full name of the Subscription.\n   *\n   * @type {string}\n   * @private\n   */\n\n\n  get name() {\n    if (!this._name) {\n      const {\n        name,\n        projectId\n      } = this._subscription;\n      this._name = projectify_1.replaceProjectIdToken(name, projectId);\n    }\n\n    return this._name;\n  }\n  /**\n   * Acknowledges the supplied message.\n   *\n   * @param {Message} message The message to acknowledge.\n   * @returns {Promise}\n   * @private\n   */\n\n\n  async ack(message) {\n    if (!this._isUserSetDeadline) {\n      const ackTimeSeconds = (Date.now() - message.received) / 1000;\n\n      this._histogram.add(ackTimeSeconds);\n\n      this.ackDeadline = this._histogram.percentile(99);\n    }\n\n    this._acks.add(message);\n\n    await this._acks.onFlush();\n\n    this._inventory.remove(message);\n  }\n  /**\n   * Closes the subscriber. The returned promise will resolve once any pending\n   * acks/modAcks are finished.\n   *\n   * @returns {Promise}\n   * @private\n   */\n\n\n  async close() {\n    if (!this.isOpen) {\n      return;\n    }\n\n    this.isOpen = false;\n\n    this._stream.destroy();\n\n    this._inventory.clear();\n\n    await this._waitForFlush();\n    this.emit('close');\n  }\n  /**\n   * Gets the subscriber client instance.\n   *\n   * @returns {Promise<object>}\n   * @private\n   */\n\n\n  async getClient() {\n    const pubsub = this._subscription.pubsub;\n    const [client] = await promisify_1.promisify(pubsub.getClient_).call(pubsub, {\n      client: 'SubscriberClient'\n    });\n    return client;\n  }\n  /**\n   * Modifies the acknowledge deadline for the provided message.\n   *\n   * @param {Message} message The message to modify.\n   * @param {number} deadline The deadline.\n   * @returns {Promise}\n   * @private\n   */\n\n\n  async modAck(message, deadline) {\n    const startTime = Date.now();\n\n    this._modAcks.add(message, deadline);\n\n    await this._modAcks.onFlush();\n    const latency = (Date.now() - startTime) / 1000;\n\n    this._latencies.add(latency);\n  }\n  /**\n   * Modfies the acknowledge deadline for the provided message and then removes\n   * it from our inventory.\n   *\n   * @param {Message} message The message.\n   * @return {Promise}\n   * @private\n   */\n\n\n  async nack(message) {\n    await this.modAck(message, 0);\n\n    this._inventory.remove(message);\n  }\n  /**\n   * Starts pulling messages.\n   * @private\n   */\n\n\n  open() {\n    const {\n      batching,\n      flowControl,\n      streamingOptions\n    } = this._options;\n    this._acks = new message_queues_1.AckQueue(this, batching);\n    this._modAcks = new message_queues_1.ModAckQueue(this, batching);\n    this._inventory = new lease_manager_1.LeaseManager(this, flowControl);\n    this._stream = new message_stream_1.MessageStream(this, streamingOptions);\n\n    this._stream.on('error', err => this.emit('error', err)).on('data', data => this._onData(data)).once('close', () => this.close());\n\n    this._inventory.on('full', () => this._stream.pause()).on('free', () => this._stream.resume());\n\n    this.isOpen = true;\n  }\n  /**\n   * Sets subscriber options.\n   *\n   * @param {SubscriberOptions} options The options.\n   * @private\n   */\n\n\n  setOptions(options) {\n    this._options = options;\n    this._useOpentelemetry = options.enableOpenTelemetryTracing || false;\n\n    if (options.ackDeadline) {\n      this.ackDeadline = options.ackDeadline;\n      this._isUserSetDeadline = true;\n    }\n\n    this.useLegacyFlowControl = options.useLegacyFlowControl || false;\n\n    if (options.flowControl) {\n      this.maxMessages = options.flowControl.maxMessages || default_options_1.defaultOptions.subscription.maxOutstandingMessages;\n      this.maxBytes = options.flowControl.maxBytes || default_options_1.defaultOptions.subscription.maxOutstandingBytes; // In the event that the user has specified the maxMessages option, we\n      // want to make sure that the maxStreams option isn't higher.\n      // It doesn't really make sense to open 5 streams if the user only wants\n      // 1 message at a time.\n\n      if (!options.streamingOptions) {\n        options.streamingOptions = {};\n      }\n\n      const {\n        maxStreams = default_options_1.defaultOptions.subscription.maxStreams\n      } = options.streamingOptions;\n      options.streamingOptions.maxStreams = Math.min(maxStreams, this.maxMessages);\n    }\n  }\n  /**\n   * Constructs an OpenTelemetry span from the incoming message.\n   *\n   * @param {Message} message One of the received messages\n   * @private\n   */\n\n\n  _constructSpan(message) {\n    // Handle cases where OpenTelemetry is disabled or no span context was sent through message\n    if (!this._useOpentelemetry || !message.attributes || !message.attributes['googclient_OpenTelemetrySpanContext']) {\n      return undefined;\n    }\n\n    const spanValue = message.attributes['googclient_OpenTelemetrySpanContext'];\n    const parentSpanContext = spanValue ? JSON.parse(spanValue) : undefined;\n    const spanAttributes = {\n      // Original span attributes\n      ackId: message.ackId,\n      deliveryAttempt: message.deliveryAttempt,\n      //\n      // based on https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/messaging.md#topic-with-multiple-consumers\n      [semantic_conventions_1.SemanticAttributes.MESSAGING_SYSTEM]: 'pubsub',\n      [semantic_conventions_1.SemanticAttributes.MESSAGING_OPERATION]: 'process',\n      [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION]: this.name,\n      [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION_KIND]: 'topic',\n      [semantic_conventions_1.SemanticAttributes.MESSAGING_MESSAGE_ID]: message.id,\n      [semantic_conventions_1.SemanticAttributes.MESSAGING_PROTOCOL]: 'pubsub',\n      [semantic_conventions_1.SemanticAttributes.MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES]: message.data.length,\n      // Not in Opentelemetry semantic convention but mimics naming\n      'messaging.pubsub.received_at': message.received,\n      'messaging.pubsub.acknowlege_id': message.ackId,\n      'messaging.pubsub.delivery_attempt': message.deliveryAttempt\n    }; // Subscriber spans should always have a publisher span as a parent.\n    // Return undefined if no parent is provided\n\n    const spanName = `${this.name} process`;\n    const span = parentSpanContext ? opentelemetry_tracing_1.createSpan(spanName.trim(), api_1.SpanKind.CONSUMER, spanAttributes, parentSpanContext) : undefined;\n    return span;\n  }\n  /**\n   * Callback to be invoked when a new message is available.\n   *\n   * New messages will be added to the subscribers inventory, which in turn will\n   * automatically extend the messages ack deadline until either:\n   *   a. the user acks/nacks it\n   *   b. the maxExtension option is hit\n   *\n   * If the message puts us at/over capacity, then we'll pause our message\n   * stream until we've freed up some inventory space.\n   *\n   * New messages must immediately issue a ModifyAckDeadline request\n   * (aka receipt) to confirm with the backend that we did infact receive the\n   * message and its ok to start ticking down on the deadline.\n   *\n   * @private\n   */\n\n\n  _onData({\n    receivedMessages\n  }) {\n    for (const data of receivedMessages) {\n      const message = new Message(this, data);\n\n      const span = this._constructSpan(message);\n\n      if (this.isOpen) {\n        message.modAck(this.ackDeadline);\n\n        this._inventory.add(message);\n      } else {\n        message.nack();\n      }\n\n      if (span) {\n        span.end();\n      }\n    }\n  }\n  /**\n   * Returns a promise that will resolve once all pending requests have settled.\n   *\n   * @private\n   *\n   * @returns {Promise}\n   */\n\n\n  async _waitForFlush() {\n    const promises = [];\n\n    if (this._acks.numPendingRequests) {\n      promises.push(this._acks.onFlush());\n\n      this._acks.flush();\n    }\n\n    if (this._modAcks.numPendingRequests) {\n      promises.push(this._modAcks.onFlush());\n\n      this._modAcks.flush();\n    }\n\n    if (this._acks.numInFlightRequests) {\n      promises.push(this._acks.onDrain());\n    }\n\n    if (this._modAcks.numInFlightRequests) {\n      promises.push(this._modAcks.onDrain());\n    }\n\n    await Promise.all(promises);\n  }\n\n}\n\nexports.Subscriber = Subscriber;","map":{"version":3,"sources":["../../src/subscriber.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Subscriber = exports.Message = void 0;\nconst precise_date_1 = require(\"@google-cloud/precise-date\");\nconst projectify_1 = require(\"@google-cloud/projectify\");\nconst promisify_1 = require(\"@google-cloud/promisify\");\nconst events_1 = require(\"events\");\nconst api_1 = require(\"@opentelemetry/api\");\nconst semantic_conventions_1 = require(\"@opentelemetry/semantic-conventions\");\nconst histogram_1 = require(\"./histogram\");\nconst lease_manager_1 = require(\"./lease-manager\");\nconst message_queues_1 = require(\"./message-queues\");\nconst message_stream_1 = require(\"./message-stream\");\nconst default_options_1 = require(\"./default-options\");\nconst opentelemetry_tracing_1 = require(\"./opentelemetry-tracing\");\n/**\n * Date object with nanosecond precision. Supports all standard Date arguments\n * in addition to several custom types.\n *\n * @external PreciseDate\n * @see {@link https://github.com/googleapis/nodejs-precise-date|PreciseDate}\n */\n/**\n * Message objects provide a simple interface for users to get message data and\n * acknowledge the message.\n *\n * @example\n * subscription.on('message', message => {\n *   // {\n *   //   ackId: 'RUFeQBJMJAxESVMrQwsqWBFOBCEhPjA',\n *   //   attributes: {key: 'value'},\n *   //   data: Buffer.from('Hello, world!'),\n *   //   id: '1551297743043',\n *   //   orderingKey: 'ordering-key',\n *   //   publishTime: new PreciseDate('2019-02-27T20:02:19.029534186Z'),\n *   //   received: 1551297743043,\n *   //   length: 13\n *   // }\n * });\n */\nclass Message {\n    /**\n     * @hideconstructor\n     *\n     * @param {Subscriber} sub The parent subscriber.\n     * @param {object} message The raw message response.\n     */\n    constructor(sub, { ackId, message, deliveryAttempt }) {\n        /**\n         * This ID is used to acknowledge the message.\n         *\n         * @name Message#ackId\n         * @type {string}\n         */\n        this.ackId = ackId;\n        /**\n         * Optional attributes for this message.\n         *\n         * @name Message#attributes\n         * @type {object}\n         */\n        this.attributes = message.attributes || {};\n        /**\n         * The message data as a Buffer.\n         *\n         * @name Message#data\n         * @type {Buffer}\n         */\n        this.data = message.data;\n        /**\n         * Delivery attempt counter is 1 + (the sum of number of NACKs and number of\n         * ack_deadline exceeds) for this message.\n         *\n         * @name Message#deliveryAttempt\n         * @type {number}\n         */\n        this.deliveryAttempt = Number(deliveryAttempt || 0);\n        /**\n         * ID of the message, assigned by the server when the message is published.\n         * Guaranteed to be unique within the topic.\n         *\n         * @name Message#id\n         * @type {string}\n         */\n        this.id = message.messageId;\n        /**\n         * Identifies related messages for which publish order should be respected.\n         * If a `Subscription` has `enableMessageOrdering` set to `true`, messages\n         * published with the same `orderingKey` value will be delivered to\n         * subscribers in the order in which they are received by the Pub/Sub\n         * system.\n         *\n         * **EXPERIMENTAL:** This feature is part of a closed alpha release. This\n         * API might be changed in backward-incompatible ways and is not recommended\n         * for production use. It is not subject to any SLA or deprecation policy.\n         *\n         * @name Message#orderingKey\n         * @type {string}\n         */\n        this.orderingKey = message.orderingKey;\n        /**\n         * The time at which the message was published.\n         *\n         * @name Message#publishTime\n         * @type {external:PreciseDate}\n         */\n        this.publishTime = new precise_date_1.PreciseDate(message.publishTime);\n        /**\n         * The time at which the message was recieved by the subscription.\n         *\n         * @name Message#received\n         * @type {number}\n         */\n        this.received = Date.now();\n        this._handled = false;\n        this._length = this.data.length;\n        this._subscriber = sub;\n    }\n    /**\n     * The length of the message data.\n     *\n     * @type {number}\n     */\n    get length() {\n        return this._length;\n    }\n    /**\n     * Acknowledges the message.\n     *\n     * @example\n     * subscription.on('message', message => {\n     *   message.ack();\n     * });\n     */\n    ack() {\n        if (!this._handled) {\n            this._handled = true;\n            this._subscriber.ack(this);\n        }\n    }\n    /**\n     * Modifies the ack deadline.\n     *\n     * @param {number} deadline The number of seconds to extend the deadline.\n     * @private\n     */\n    modAck(deadline) {\n        if (!this._handled) {\n            this._subscriber.modAck(this, deadline);\n        }\n    }\n    /**\n     * Removes the message from our inventory and schedules it to be redelivered.\n     *\n     * @example\n     * subscription.on('message', message => {\n     *   message.nack();\n     * });\n     */\n    nack() {\n        if (!this._handled) {\n            this._handled = true;\n            this._subscriber.nack(this);\n        }\n    }\n}\nexports.Message = Message;\n/**\n * @typedef {object} SubscriberOptions\n * @property {number} [ackDeadline=10] Acknowledge deadline in seconds. If left\n *     unset the initial value will be 10 seconds, but it will evolve into the\n *     99th percentile time it takes to acknowledge a message.\n * @property {BatchOptions} [batching] Request batching options.\n * @property {FlowControlOptions} [flowControl] Flow control options.\n * @property {boolean} [useLegacyFlowControl] Disables enforcing flow control\n *     settings at the Cloud PubSub server and uses the less accurate method\n *     of only enforcing flow control at the client side.\n * @property {MessageStreamOptions} [streamingOptions] Streaming options.\n */\n/**\n * Subscriber class is used to manage all message related functionality.\n *\n * @private\n * @class\n *\n * @param {Subscription} subscription The corresponding subscription.\n * @param {SubscriberOptions} options The subscriber options.\n */\nclass Subscriber extends events_1.EventEmitter {\n    constructor(subscription, options = {}) {\n        super();\n        this.ackDeadline = 10;\n        this.maxMessages = default_options_1.defaultOptions.subscription.maxOutstandingMessages;\n        this.maxBytes = default_options_1.defaultOptions.subscription.maxOutstandingBytes;\n        this.useLegacyFlowControl = false;\n        this.isOpen = false;\n        this._isUserSetDeadline = false;\n        this._useOpentelemetry = false;\n        this._histogram = new histogram_1.Histogram({ min: 10, max: 600 });\n        this._latencies = new histogram_1.Histogram();\n        this._subscription = subscription;\n        this.setOptions(options);\n    }\n    /**\n     * The 99th percentile of request latencies.\n     *\n     * @type {number}\n     * @private\n     */\n    get modAckLatency() {\n        const latency = this._latencies.percentile(99);\n        let bufferTime = 0;\n        if (this._modAcks) {\n            bufferTime = this._modAcks.maxMilliseconds;\n        }\n        return latency * 1000 + bufferTime;\n    }\n    /**\n     * The full name of the Subscription.\n     *\n     * @type {string}\n     * @private\n     */\n    get name() {\n        if (!this._name) {\n            const { name, projectId } = this._subscription;\n            this._name = projectify_1.replaceProjectIdToken(name, projectId);\n        }\n        return this._name;\n    }\n    /**\n     * Acknowledges the supplied message.\n     *\n     * @param {Message} message The message to acknowledge.\n     * @returns {Promise}\n     * @private\n     */\n    async ack(message) {\n        if (!this._isUserSetDeadline) {\n            const ackTimeSeconds = (Date.now() - message.received) / 1000;\n            this._histogram.add(ackTimeSeconds);\n            this.ackDeadline = this._histogram.percentile(99);\n        }\n        this._acks.add(message);\n        await this._acks.onFlush();\n        this._inventory.remove(message);\n    }\n    /**\n     * Closes the subscriber. The returned promise will resolve once any pending\n     * acks/modAcks are finished.\n     *\n     * @returns {Promise}\n     * @private\n     */\n    async close() {\n        if (!this.isOpen) {\n            return;\n        }\n        this.isOpen = false;\n        this._stream.destroy();\n        this._inventory.clear();\n        await this._waitForFlush();\n        this.emit('close');\n    }\n    /**\n     * Gets the subscriber client instance.\n     *\n     * @returns {Promise<object>}\n     * @private\n     */\n    async getClient() {\n        const pubsub = this._subscription.pubsub;\n        const [client] = await promisify_1.promisify(pubsub.getClient_).call(pubsub, {\n            client: 'SubscriberClient',\n        });\n        return client;\n    }\n    /**\n     * Modifies the acknowledge deadline for the provided message.\n     *\n     * @param {Message} message The message to modify.\n     * @param {number} deadline The deadline.\n     * @returns {Promise}\n     * @private\n     */\n    async modAck(message, deadline) {\n        const startTime = Date.now();\n        this._modAcks.add(message, deadline);\n        await this._modAcks.onFlush();\n        const latency = (Date.now() - startTime) / 1000;\n        this._latencies.add(latency);\n    }\n    /**\n     * Modfies the acknowledge deadline for the provided message and then removes\n     * it from our inventory.\n     *\n     * @param {Message} message The message.\n     * @return {Promise}\n     * @private\n     */\n    async nack(message) {\n        await this.modAck(message, 0);\n        this._inventory.remove(message);\n    }\n    /**\n     * Starts pulling messages.\n     * @private\n     */\n    open() {\n        const { batching, flowControl, streamingOptions } = this._options;\n        this._acks = new message_queues_1.AckQueue(this, batching);\n        this._modAcks = new message_queues_1.ModAckQueue(this, batching);\n        this._inventory = new lease_manager_1.LeaseManager(this, flowControl);\n        this._stream = new message_stream_1.MessageStream(this, streamingOptions);\n        this._stream\n            .on('error', err => this.emit('error', err))\n            .on('data', (data) => this._onData(data))\n            .once('close', () => this.close());\n        this._inventory\n            .on('full', () => this._stream.pause())\n            .on('free', () => this._stream.resume());\n        this.isOpen = true;\n    }\n    /**\n     * Sets subscriber options.\n     *\n     * @param {SubscriberOptions} options The options.\n     * @private\n     */\n    setOptions(options) {\n        this._options = options;\n        this._useOpentelemetry = options.enableOpenTelemetryTracing || false;\n        if (options.ackDeadline) {\n            this.ackDeadline = options.ackDeadline;\n            this._isUserSetDeadline = true;\n        }\n        this.useLegacyFlowControl = options.useLegacyFlowControl || false;\n        if (options.flowControl) {\n            this.maxMessages =\n                options.flowControl.maxMessages ||\n                    default_options_1.defaultOptions.subscription.maxOutstandingMessages;\n            this.maxBytes =\n                options.flowControl.maxBytes ||\n                    default_options_1.defaultOptions.subscription.maxOutstandingBytes;\n            // In the event that the user has specified the maxMessages option, we\n            // want to make sure that the maxStreams option isn't higher.\n            // It doesn't really make sense to open 5 streams if the user only wants\n            // 1 message at a time.\n            if (!options.streamingOptions) {\n                options.streamingOptions = {};\n            }\n            const { maxStreams = default_options_1.defaultOptions.subscription.maxStreams } = options.streamingOptions;\n            options.streamingOptions.maxStreams = Math.min(maxStreams, this.maxMessages);\n        }\n    }\n    /**\n     * Constructs an OpenTelemetry span from the incoming message.\n     *\n     * @param {Message} message One of the received messages\n     * @private\n     */\n    _constructSpan(message) {\n        // Handle cases where OpenTelemetry is disabled or no span context was sent through message\n        if (!this._useOpentelemetry ||\n            !message.attributes ||\n            !message.attributes['googclient_OpenTelemetrySpanContext']) {\n            return undefined;\n        }\n        const spanValue = message.attributes['googclient_OpenTelemetrySpanContext'];\n        const parentSpanContext = spanValue\n            ? JSON.parse(spanValue)\n            : undefined;\n        const spanAttributes = {\n            // Original span attributes\n            ackId: message.ackId,\n            deliveryAttempt: message.deliveryAttempt,\n            //\n            // based on https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/messaging.md#topic-with-multiple-consumers\n            [semantic_conventions_1.SemanticAttributes.MESSAGING_SYSTEM]: 'pubsub',\n            [semantic_conventions_1.SemanticAttributes.MESSAGING_OPERATION]: 'process',\n            [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION]: this.name,\n            [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION_KIND]: 'topic',\n            [semantic_conventions_1.SemanticAttributes.MESSAGING_MESSAGE_ID]: message.id,\n            [semantic_conventions_1.SemanticAttributes.MESSAGING_PROTOCOL]: 'pubsub',\n            [semantic_conventions_1.SemanticAttributes.MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES]: message.data.length,\n            // Not in Opentelemetry semantic convention but mimics naming\n            'messaging.pubsub.received_at': message.received,\n            'messaging.pubsub.acknowlege_id': message.ackId,\n            'messaging.pubsub.delivery_attempt': message.deliveryAttempt,\n        };\n        // Subscriber spans should always have a publisher span as a parent.\n        // Return undefined if no parent is provided\n        const spanName = `${this.name} process`;\n        const span = parentSpanContext\n            ? opentelemetry_tracing_1.createSpan(spanName.trim(), api_1.SpanKind.CONSUMER, spanAttributes, parentSpanContext)\n            : undefined;\n        return span;\n    }\n    /**\n     * Callback to be invoked when a new message is available.\n     *\n     * New messages will be added to the subscribers inventory, which in turn will\n     * automatically extend the messages ack deadline until either:\n     *   a. the user acks/nacks it\n     *   b. the maxExtension option is hit\n     *\n     * If the message puts us at/over capacity, then we'll pause our message\n     * stream until we've freed up some inventory space.\n     *\n     * New messages must immediately issue a ModifyAckDeadline request\n     * (aka receipt) to confirm with the backend that we did infact receive the\n     * message and its ok to start ticking down on the deadline.\n     *\n     * @private\n     */\n    _onData({ receivedMessages }) {\n        for (const data of receivedMessages) {\n            const message = new Message(this, data);\n            const span = this._constructSpan(message);\n            if (this.isOpen) {\n                message.modAck(this.ackDeadline);\n                this._inventory.add(message);\n            }\n            else {\n                message.nack();\n            }\n            if (span) {\n                span.end();\n            }\n        }\n    }\n    /**\n     * Returns a promise that will resolve once all pending requests have settled.\n     *\n     * @private\n     *\n     * @returns {Promise}\n     */\n    async _waitForFlush() {\n        const promises = [];\n        if (this._acks.numPendingRequests) {\n            promises.push(this._acks.onFlush());\n            this._acks.flush();\n        }\n        if (this._modAcks.numPendingRequests) {\n            promises.push(this._modAcks.onFlush());\n            this._modAcks.flush();\n        }\n        if (this._acks.numInFlightRequests) {\n            promises.push(this._acks.onDrain());\n        }\n        if (this._modAcks.numInFlightRequests) {\n            promises.push(this._modAcks.onDrain());\n        }\n        await Promise.all(promises);\n    }\n}\nexports.Subscriber = Subscriber;\n//# sourceMappingURL=subscriber.js.map"]},"metadata":{},"sourceType":"script"}