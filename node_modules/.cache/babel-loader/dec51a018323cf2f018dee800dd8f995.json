{"ast":null,"code":"import getOrCreateMeasurementElement from './getOrCreateMeasurementElement';\nvar MEASUREMENT_ELEMENT_ID = '__visx_splitpath_svg_path_measurement_id';\n\nvar TRUE = function TRUE() {\n  return true;\n};\n\nexport default function getSplitLineSegments(_ref) {\n  var path = _ref.path,\n      pointsInSegments = _ref.pointsInSegments,\n      _ref$segmentation = _ref.segmentation,\n      segmentation = _ref$segmentation === void 0 ? 'x' : _ref$segmentation,\n      _ref$sampleRate = _ref.sampleRate,\n      sampleRate = _ref$sampleRate === void 0 ? 1 : _ref$sampleRate;\n\n  try {\n    var pathElement = getOrCreateMeasurementElement(MEASUREMENT_ELEMENT_ID);\n    pathElement.setAttribute('d', path);\n    var totalLength = pathElement.getTotalLength();\n    var numSegments = pointsInSegments.length;\n    var lineSegments = pointsInSegments.map(function () {\n      return [];\n    });\n\n    if (segmentation === 'x' || segmentation === 'y') {\n      var segmentStarts = pointsInSegments.map(function (points) {\n        var _points$find;\n\n        return (_points$find = points.find(function (p) {\n          return typeof p[segmentation] === 'number';\n        })) == null ? void 0 : _points$find[segmentation];\n      });\n      var first = pathElement.getPointAtLength(0);\n      var last = pathElement.getPointAtLength(totalLength);\n      var isIncreasing = last[segmentation] > first[segmentation];\n      var isBeyondSegmentStart = isIncreasing ? segmentStarts.map(function (start) {\n        return typeof start === 'undefined' ? TRUE : function (xOrY) {\n          return xOrY >= start;\n        };\n      }) : segmentStarts.map(function (start) {\n        return typeof start === 'undefined' ? TRUE : function (xOrY) {\n          return xOrY <= start;\n        };\n      });\n      var currentSegment = 0;\n\n      for (var distance = 0; distance <= totalLength; distance += sampleRate) {\n        var sample = pathElement.getPointAtLength(distance);\n        var position = sample[segmentation]; // find the current segment to which this sample belongs\n\n        while (currentSegment < numSegments - 1 && isBeyondSegmentStart[currentSegment + 1](position)) {\n          currentSegment += 1;\n        } // add sample to segment\n\n\n        lineSegments[currentSegment].push(sample);\n      }\n    } else {\n      // segmentation === \"length\"\n      var numPointsInSegment = pointsInSegments.map(function (points) {\n        return points.length;\n      });\n      var numPoints = numPointsInSegment.reduce(function (sum, curr) {\n        return sum + curr;\n      }, 0);\n      var lengthBetweenPoints = totalLength / Math.max(1, numPoints - 1);\n\n      var _segmentStarts = numPointsInSegment.slice(0, numSegments - 1);\n\n      _segmentStarts.unshift(0);\n\n      for (var i = 2; i < numSegments; i += 1) {\n        _segmentStarts[i] += _segmentStarts[i - 1];\n      }\n\n      for (var _i = 0; _i < numSegments; _i += 1) {\n        _segmentStarts[_i] *= lengthBetweenPoints;\n      }\n\n      var _currentSegment = 0;\n\n      for (var _distance = 0; _distance <= totalLength; _distance += sampleRate) {\n        var _sample = pathElement.getPointAtLength(_distance); // find the current segment to which this sample belongs\n\n\n        while (_currentSegment < numSegments - 1 && _distance >= _segmentStarts[_currentSegment + 1]) {\n          _currentSegment += 1;\n        } // add sample to segment\n\n\n        lineSegments[_currentSegment].push(_sample);\n      }\n    }\n\n    return lineSegments;\n  } catch (e) {\n    return [];\n  }\n}","map":{"version":3,"sources":["C:/remotePackRlab-acab49ee44aa8f06acbfc147116dbc3387885161/node_modules/@visx/shape/esm/util/getSplitLineSegments.js"],"names":["getOrCreateMeasurementElement","MEASUREMENT_ELEMENT_ID","TRUE","getSplitLineSegments","_ref","path","pointsInSegments","_ref$segmentation","segmentation","_ref$sampleRate","sampleRate","pathElement","setAttribute","totalLength","getTotalLength","numSegments","length","lineSegments","map","segmentStarts","points","_points$find","find","p","first","getPointAtLength","last","isIncreasing","isBeyondSegmentStart","start","xOrY","currentSegment","distance","sample","position","push","numPointsInSegment","numPoints","reduce","sum","curr","lengthBetweenPoints","Math","max","_segmentStarts","slice","unshift","i","_i","_currentSegment","_distance","_sample","e"],"mappings":"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","sourcesContent":["import getOrCreateMeasurementElement from './getOrCreateMeasurementElement';\nvar MEASUREMENT_ELEMENT_ID = '__visx_splitpath_svg_path_measurement_id';\n\nvar TRUE = function TRUE() {\n  return true;\n};\n\nexport default function getSplitLineSegments(_ref) {\n  var path = _ref.path,\n      pointsInSegments = _ref.pointsInSegments,\n      _ref$segmentation = _ref.segmentation,\n      segmentation = _ref$segmentation === void 0 ? 'x' : _ref$segmentation,\n      _ref$sampleRate = _ref.sampleRate,\n      sampleRate = _ref$sampleRate === void 0 ? 1 : _ref$sampleRate;\n\n  try {\n    var pathElement = getOrCreateMeasurementElement(MEASUREMENT_ELEMENT_ID);\n    pathElement.setAttribute('d', path);\n    var totalLength = pathElement.getTotalLength();\n    var numSegments = pointsInSegments.length;\n    var lineSegments = pointsInSegments.map(function () {\n      return [];\n    });\n\n    if (segmentation === 'x' || segmentation === 'y') {\n      var segmentStarts = pointsInSegments.map(function (points) {\n        var _points$find;\n\n        return (_points$find = points.find(function (p) {\n          return typeof p[segmentation] === 'number';\n        })) == null ? void 0 : _points$find[segmentation];\n      });\n      var first = pathElement.getPointAtLength(0);\n      var last = pathElement.getPointAtLength(totalLength);\n      var isIncreasing = last[segmentation] > first[segmentation];\n      var isBeyondSegmentStart = isIncreasing ? segmentStarts.map(function (start) {\n        return typeof start === 'undefined' ? TRUE : function (xOrY) {\n          return xOrY >= start;\n        };\n      }) : segmentStarts.map(function (start) {\n        return typeof start === 'undefined' ? TRUE : function (xOrY) {\n          return xOrY <= start;\n        };\n      });\n      var currentSegment = 0;\n\n      for (var distance = 0; distance <= totalLength; distance += sampleRate) {\n        var sample = pathElement.getPointAtLength(distance);\n        var position = sample[segmentation]; // find the current segment to which this sample belongs\n\n        while (currentSegment < numSegments - 1 && isBeyondSegmentStart[currentSegment + 1](position)) {\n          currentSegment += 1;\n        } // add sample to segment\n\n\n        lineSegments[currentSegment].push(sample);\n      }\n    } else {\n      // segmentation === \"length\"\n      var numPointsInSegment = pointsInSegments.map(function (points) {\n        return points.length;\n      });\n      var numPoints = numPointsInSegment.reduce(function (sum, curr) {\n        return sum + curr;\n      }, 0);\n      var lengthBetweenPoints = totalLength / Math.max(1, numPoints - 1);\n\n      var _segmentStarts = numPointsInSegment.slice(0, numSegments - 1);\n\n      _segmentStarts.unshift(0);\n\n      for (var i = 2; i < numSegments; i += 1) {\n        _segmentStarts[i] += _segmentStarts[i - 1];\n      }\n\n      for (var _i = 0; _i < numSegments; _i += 1) {\n        _segmentStarts[_i] *= lengthBetweenPoints;\n      }\n\n      var _currentSegment = 0;\n\n      for (var _distance = 0; _distance <= totalLength; _distance += sampleRate) {\n        var _sample = pathElement.getPointAtLength(_distance); // find the current segment to which this sample belongs\n\n\n        while (_currentSegment < numSegments - 1 && _distance >= _segmentStarts[_currentSegment + 1]) {\n          _currentSegment += 1;\n        } // add sample to segment\n\n\n        lineSegments[_currentSegment].push(_sample);\n      }\n    }\n\n    return lineSegments;\n  } catch (e) {\n    return [];\n  }\n}"]},"metadata":{},"sourceType":"module"}