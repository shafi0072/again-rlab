{"ast":null,"code":"import React, { useCallback, useContext, useEffect, useRef } from 'react';\nimport { localPoint } from '@visx/event';\nimport EventEmitterContext from '../context/EventEmitterContext';\n/**\n * Hook for optionally subscribing to a specified EventType,\n * and returns emitter for emitting events.\n */\n\nexport default function useEventEmitter(\n/** Type of event to subscribe to. */\neventType,\n/** Handler invoked on emission of EventType event.  */\nhandler,\n/** Optional valid sources for EventType subscription. */\nallowedSources) {\n  var emitter = useContext(EventEmitterContext);\n  var allowedSourcesRef = useRef();\n  allowedSourcesRef.current = allowedSources; // use ref so allowedSources[] can change without creating new handlers\n  // wrap emitter.emit so we can enforce stricter type signature\n\n  var emit = useCallback(function (type, event, source) {\n    if (emitter) {\n      emitter.emit(type, {\n        event: event,\n        svgPoint: localPoint(event),\n        source: source\n      });\n    }\n  }, [emitter]);\n  useEffect(function () {\n    if (emitter && eventType && handler) {\n      // register handler, with source filtering as needed\n      var handlerWithSourceFilter = function handlerWithSourceFilter(params) {\n        var _allowedSourcesRef$cu;\n\n        if (!allowedSourcesRef.current || (params == null ? void 0 : params.source) && ((_allowedSourcesRef$cu = allowedSourcesRef.current) == null ? void 0 : _allowedSourcesRef$cu.includes(params.source))) {\n          handler(params);\n        }\n      };\n\n      emitter.on(eventType, handlerWithSourceFilter);\n      return function () {\n        return emitter == null ? void 0 : emitter.off(eventType, handlerWithSourceFilter);\n      };\n    }\n\n    return undefined;\n  }, [emitter, eventType, handler]);\n  return emitter ? emit : null;\n}","map":{"version":3,"sources":["C:/remotePackRlab-acab49ee44aa8f06acbfc147116dbc3387885161/node_modules/@visx/xychart/esm/hooks/useEventEmitter.js"],"names":["React","useCallback","useContext","useEffect","useRef","localPoint","EventEmitterContext","useEventEmitter","eventType","handler","allowedSources","emitter","allowedSourcesRef","current","emit","type","event","source","svgPoint","handlerWithSourceFilter","params","_allowedSourcesRef$cu","includes","on","off","undefined"],"mappings":"AAAA,OAAOA,KAAP,IAAgBC,WAAhB,EAA6BC,UAA7B,EAAyCC,SAAzC,EAAoDC,MAApD,QAAkE,OAAlE;AACA,SAASC,UAAT,QAA2B,aAA3B;AACA,OAAOC,mBAAP,MAAgC,gCAAhC;AAEA;AACA;AACA;AACA;;AACA,eAAe,SAASC,eAAT;AACf;AACAC,SAFe;AAGf;AACAC,OAJe;AAKf;AACAC,cANe,EAMC;AACd,MAAIC,OAAO,GAAGT,UAAU,CAACI,mBAAD,CAAxB;AACA,MAAIM,iBAAiB,GAAGR,MAAM,EAA9B;AACAQ,EAAAA,iBAAiB,CAACC,OAAlB,GAA4BH,cAA5B,CAHc,CAG8B;AAC5C;;AAEA,MAAII,IAAI,GAAGb,WAAW,CAAC,UAAUc,IAAV,EAAgBC,KAAhB,EAAuBC,MAAvB,EAA+B;AACpD,QAAIN,OAAJ,EAAa;AACXA,MAAAA,OAAO,CAACG,IAAR,CAAaC,IAAb,EAAmB;AACjBC,QAAAA,KAAK,EAAEA,KADU;AAEjBE,QAAAA,QAAQ,EAAEb,UAAU,CAACW,KAAD,CAFH;AAGjBC,QAAAA,MAAM,EAAEA;AAHS,OAAnB;AAKD;AACF,GARqB,EAQnB,CAACN,OAAD,CARmB,CAAtB;AASAR,EAAAA,SAAS,CAAC,YAAY;AACpB,QAAIQ,OAAO,IAAIH,SAAX,IAAwBC,OAA5B,EAAqC;AACnC;AACA,UAAIU,uBAAuB,GAAG,SAASA,uBAAT,CAAiCC,MAAjC,EAAyC;AACrE,YAAIC,qBAAJ;;AAEA,YAAI,CAACT,iBAAiB,CAACC,OAAnB,IAA8B,CAACO,MAAM,IAAI,IAAV,GAAiB,KAAK,CAAtB,GAA0BA,MAAM,CAACH,MAAlC,MAA8C,CAACI,qBAAqB,GAAGT,iBAAiB,CAACC,OAA3C,KAAuD,IAAvD,GAA8D,KAAK,CAAnE,GAAuEQ,qBAAqB,CAACC,QAAtB,CAA+BF,MAAM,CAACH,MAAtC,CAArH,CAAlC,EAAuM;AACrMR,UAAAA,OAAO,CAACW,MAAD,CAAP;AACD;AACF,OAND;;AAQAT,MAAAA,OAAO,CAACY,EAAR,CAAWf,SAAX,EAAsBW,uBAAtB;AACA,aAAO,YAAY;AACjB,eAAOR,OAAO,IAAI,IAAX,GAAkB,KAAK,CAAvB,GAA2BA,OAAO,CAACa,GAAR,CAAYhB,SAAZ,EAAuBW,uBAAvB,CAAlC;AACD,OAFD;AAGD;;AAED,WAAOM,SAAP;AACD,GAlBQ,EAkBN,CAACd,OAAD,EAAUH,SAAV,EAAqBC,OAArB,CAlBM,CAAT;AAmBA,SAAOE,OAAO,GAAGG,IAAH,GAAU,IAAxB;AACD","sourcesContent":["import React, { useCallback, useContext, useEffect, useRef } from 'react';\nimport { localPoint } from '@visx/event';\nimport EventEmitterContext from '../context/EventEmitterContext';\n\n/**\n * Hook for optionally subscribing to a specified EventType,\n * and returns emitter for emitting events.\n */\nexport default function useEventEmitter(\n/** Type of event to subscribe to. */\neventType,\n/** Handler invoked on emission of EventType event.  */\nhandler,\n/** Optional valid sources for EventType subscription. */\nallowedSources) {\n  var emitter = useContext(EventEmitterContext);\n  var allowedSourcesRef = useRef();\n  allowedSourcesRef.current = allowedSources; // use ref so allowedSources[] can change without creating new handlers\n  // wrap emitter.emit so we can enforce stricter type signature\n\n  var emit = useCallback(function (type, event, source) {\n    if (emitter) {\n      emitter.emit(type, {\n        event: event,\n        svgPoint: localPoint(event),\n        source: source\n      });\n    }\n  }, [emitter]);\n  useEffect(function () {\n    if (emitter && eventType && handler) {\n      // register handler, with source filtering as needed\n      var handlerWithSourceFilter = function handlerWithSourceFilter(params) {\n        var _allowedSourcesRef$cu;\n\n        if (!allowedSourcesRef.current || (params == null ? void 0 : params.source) && ((_allowedSourcesRef$cu = allowedSourcesRef.current) == null ? void 0 : _allowedSourcesRef$cu.includes(params.source))) {\n          handler(params);\n        }\n      };\n\n      emitter.on(eventType, handlerWithSourceFilter);\n      return function () {\n        return emitter == null ? void 0 : emitter.off(eventType, handlerWithSourceFilter);\n      };\n    }\n\n    return undefined;\n  }, [emitter, eventType, handler]);\n  return emitter ? emit : null;\n}"]},"metadata":{},"sourceType":"module"}