{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MessageStream = exports.ChannelError = exports.StatusError = void 0;\n\nconst promisify_1 = require(\"@google-cloud/promisify\");\n\nconst google_gax_1 = require(\"google-gax\");\n\nconst isStreamEnded = require(\"is-stream-ended\");\n\nconst stream_1 = require(\"stream\");\n\nconst pull_retry_1 = require(\"./pull-retry\");\n\nconst default_options_1 = require(\"./default-options\");\n/*!\n * Frequency to ping streams.\n */\n\n\nconst KEEP_ALIVE_INTERVAL = 30000;\n/*!\n * Deadline for the stream.\n */\n\nconst PULL_TIMEOUT = require('./v1/subscriber_client_config.json').interfaces['google.pubsub.v1.Subscriber'].methods.StreamingPull.timeout_millis;\n/*!\n * default stream options\n */\n\n\nconst DEFAULT_OPTIONS = {\n  highWaterMark: 0,\n  maxStreams: default_options_1.defaultOptions.subscription.maxStreams,\n  timeout: 300000\n};\n/**\n * Error wrapper for gRPC status objects.\n *\n * @class\n *\n * @param {object} status The gRPC status object.\n */\n\nclass StatusError extends Error {\n  constructor(status) {\n    super(status.details);\n    this.code = status.code;\n    this.details = status.details;\n    this.metadata = status.metadata;\n  }\n\n}\n\nexports.StatusError = StatusError;\n/**\n * Error thrown when we fail to open a channel for the message stream.\n *\n * @class\n *\n * @param {Error} err The original error.\n */\n\nclass ChannelError extends Error {\n  constructor(err) {\n    super(`Failed to connect to channel. Reason: ${process.env.DEBUG_GRPC ? err.stack : err.message}`);\n    this.code = err.message.includes('deadline') ? google_gax_1.grpc.status.DEADLINE_EXCEEDED : google_gax_1.grpc.status.UNKNOWN;\n    this.details = err.message;\n    this.metadata = new google_gax_1.grpc.Metadata();\n  }\n\n}\n\nexports.ChannelError = ChannelError;\n/**\n * @typedef {object} MessageStreamOptions\n * @property {number} [highWaterMark=0] Configures the Buffer level for all\n *     underlying streams. See\n *     {@link https://nodejs.org/en/docs/guides/backpressuring-in-streams/} for\n *     more details.\n * @property {number} [maxStreams=5] Number of streaming connections to make.\n * @property {number} [timeout=300000] Timeout for establishing a connection.\n */\n\n/**\n * Streaming class used to manage multiple StreamingPull requests.\n *\n * @private\n * @class\n *\n * @param {Subscriber} sub The parent subscriber.\n * @param {MessageStreamOptions} [options] The message stream options.\n */\n\nclass MessageStream extends stream_1.PassThrough {\n  constructor(sub, options = {}) {\n    options = Object.assign({}, DEFAULT_OPTIONS, options);\n    super({\n      objectMode: true,\n      highWaterMark: options.highWaterMark\n    });\n    this._options = options;\n    this._retrier = new pull_retry_1.PullRetry();\n    this._streams = new Map();\n    this._subscriber = sub;\n\n    this._fillStreamPool();\n\n    this._keepAliveHandle = setInterval(() => this._keepAlive(), KEEP_ALIVE_INTERVAL);\n\n    this._keepAliveHandle.unref();\n  }\n  /**\n   * Destroys the stream and any underlying streams.\n   *\n   * @param {error?} error An error to emit, if any.\n   * @private\n   */\n\n\n  destroy(error) {\n    // We can't assume Node has taken care of this in <14.\n    if (this.destroyed) {\n      return;\n    }\n\n    super.destroy(error ? error : undefined);\n  }\n  /**\n   * Destroys the stream and any underlying streams.\n   *\n   * @param {error?} error An error to emit, if any.\n   * @param {Function} callback Callback for completion of any destruction.\n   * @private\n   */\n\n\n  _destroy(error, callback) {\n    this.destroyed = true;\n    clearInterval(this._keepAliveHandle);\n\n    for (const stream of this._streams.keys()) {\n      this._removeStream(stream);\n\n      stream.cancel();\n    }\n\n    callback(error);\n  }\n  /**\n   * Adds a StreamingPull stream to the combined stream.\n   *\n   * @private\n   *\n   * @param {stream} stream The StreamingPull stream.\n   */\n\n\n  _addStream(stream) {\n    this._setHighWaterMark(stream);\n\n    this._streams.set(stream, false);\n\n    stream.on('error', err => this._onError(stream, err)).once('status', status => this._onStatus(stream, status)).pipe(this, {\n      end: false\n    });\n  }\n  /**\n   * Attempts to create and cache the desired number of StreamingPull requests.\n   * gRPC does not supply a way to confirm that a stream is connected, so our\n   * best bet is to open the streams and use the client.waitForReady() method to\n   * confirm everything is ok.\n   *\n   * @private\n   *\n   * @returns {Promise}\n   */\n\n\n  async _fillStreamPool() {\n    let client;\n\n    try {\n      client = await this._getClient();\n    } catch (e) {\n      this.destroy(e);\n    }\n\n    if (this.destroyed) {\n      return;\n    }\n\n    const deadline = Date.now() + PULL_TIMEOUT;\n    const request = {\n      subscription: this._subscriber.name,\n      streamAckDeadlineSeconds: this._subscriber.ackDeadline,\n      maxOutstandingMessages: this._subscriber.useLegacyFlowControl ? 0 : this._subscriber.maxMessages,\n      maxOutstandingBytes: this._subscriber.useLegacyFlowControl ? 0 : this._subscriber.maxBytes\n    };\n    delete this._fillHandle;\n\n    for (let i = this._streams.size; i < this._options.maxStreams; i++) {\n      const stream = client.streamingPull({\n        deadline\n      });\n\n      this._addStream(stream);\n\n      stream.write(request);\n    }\n\n    try {\n      await this._waitForClientReady(client);\n    } catch (e) {\n      this.destroy(e);\n    }\n  }\n  /**\n   * It is critical that we keep as few `PullResponse` objects in memory as\n   * possible to reduce the number of potential redeliveries. Because of this we\n   * want to bypass gax for StreamingPull requests to avoid creating a Duplexify\n   * stream, doing so essentially doubles the size of our readable buffer.\n   *\n   * @private\n   *\n   * @returns {Promise.<object>}\n   */\n\n\n  async _getClient() {\n    const client = await this._subscriber.getClient();\n    client.initialize();\n    return client.subscriberStub;\n  }\n  /**\n   * Since we do not use the streams to ack/modAck messages, they will close\n   * by themselves unless we periodically send empty messages.\n   *\n   * @private\n   */\n\n\n  _keepAlive() {\n    this._streams.forEach((receivedStatus, stream) => {\n      // its possible that a status event fires off (signaling the rpc being\n      // closed) but the stream hasn't drained yet, writing to this stream will\n      // result in a `write after end` error\n      if (!receivedStatus) {\n        stream.write({});\n      }\n    });\n  }\n  /**\n   * Once the stream has nothing left to read, we'll remove it and attempt to\n   * refill our stream pool if needed.\n   *\n   * @private\n   *\n   * @param {Duplex} stream The ended stream.\n   * @param {object} status The stream status.\n   */\n\n\n  _onEnd(stream, status) {\n    this._removeStream(stream);\n\n    if (this._fillHandle) {\n      return;\n    }\n\n    if (this._retrier.retry(status)) {\n      const delay = this._retrier.createTimeout();\n\n      this._fillHandle = setTimeout(() => this._fillStreamPool(), delay);\n    } else if (!this._streams.size) {\n      this.destroy(new StatusError(status));\n    }\n  }\n  /**\n   * gRPC will usually emit a status as a ServiceError via `error` event before\n   * it emits the status itself. In order to cut back on emitted errors, we'll\n   * wait a tick on error and ignore it if the status has been received.\n   *\n   * @private\n   *\n   * @param {stream} stream The stream that errored.\n   * @param {Error} err The error.\n   */\n\n\n  async _onError(stream, err) {\n    await promisify_1.promisify(setImmediate)();\n    const code = err.code;\n    const receivedStatus = this._streams.get(stream) !== false;\n\n    if (typeof code !== 'number' || !receivedStatus) {\n      this.emit('error', err);\n    }\n  }\n  /**\n   * gRPC streams will emit a status event once the connection has been\n   * terminated. This is preferable to end/close events because we'll receive\n   * information as to why the stream closed and if it is safe to open another.\n   *\n   * @private\n   *\n   * @param {stream} stream The stream that was closed.\n   * @param {object} status The status message stating why it was closed.\n   */\n\n\n  _onStatus(stream, status) {\n    if (this.destroyed) {\n      return;\n    }\n\n    this._streams.set(stream, true);\n\n    if (isStreamEnded(stream)) {\n      this._onEnd(stream, status);\n    } else {\n      stream.once('end', () => this._onEnd(stream, status));\n      stream.push(null);\n    }\n  }\n  /**\n   * Removes a stream from the combined stream.\n   *\n   * @private\n   *\n   * @param {stream} stream The stream to remove.\n   */\n\n\n  _removeStream(stream) {\n    stream.unpipe(this);\n\n    this._streams.delete(stream);\n  }\n  /**\n   * Neither gRPC or gax allow for the highWaterMark option to be specified.\n   * However using the default value (16) it is possible to end up with a lot of\n   * PullResponse objects stored in internal buffers. If this were to happen\n   * and the client were slow to process messages, we could potentially see a\n   * very large number of redeliveries happen before the messages even made it\n   * to the client.\n   *\n   * @private\n   *\n   * @param {Duplex} stream The duplex stream to adjust the\n   *     highWaterMarks for.\n   */\n\n\n  _setHighWaterMark(stream) {\n    stream._readableState.highWaterMark = this._options.highWaterMark;\n  }\n  /**\n   * Promisified version of gRPCs Client#waitForReady function.\n   *\n   * @private\n   *\n   * @param {object} client The gRPC client to wait for.\n   * @returns {Promise}\n   */\n\n\n  async _waitForClientReady(client) {\n    const deadline = Date.now() + this._options.timeout;\n\n    try {\n      await promisify_1.promisify(client.waitForReady).call(client, deadline);\n    } catch (e) {\n      throw new ChannelError(e);\n    }\n  }\n\n}\n\nexports.MessageStream = MessageStream;","map":{"version":3,"sources":["../../src/message-stream.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageStream = exports.ChannelError = exports.StatusError = void 0;\nconst promisify_1 = require(\"@google-cloud/promisify\");\nconst google_gax_1 = require(\"google-gax\");\nconst isStreamEnded = require(\"is-stream-ended\");\nconst stream_1 = require(\"stream\");\nconst pull_retry_1 = require(\"./pull-retry\");\nconst default_options_1 = require(\"./default-options\");\n/*!\n * Frequency to ping streams.\n */\nconst KEEP_ALIVE_INTERVAL = 30000;\n/*!\n * Deadline for the stream.\n */\nconst PULL_TIMEOUT = require('./v1/subscriber_client_config.json').interfaces['google.pubsub.v1.Subscriber'].methods.StreamingPull.timeout_millis;\n/*!\n * default stream options\n */\nconst DEFAULT_OPTIONS = {\n    highWaterMark: 0,\n    maxStreams: default_options_1.defaultOptions.subscription.maxStreams,\n    timeout: 300000,\n};\n/**\n * Error wrapper for gRPC status objects.\n *\n * @class\n *\n * @param {object} status The gRPC status object.\n */\nclass StatusError extends Error {\n    constructor(status) {\n        super(status.details);\n        this.code = status.code;\n        this.details = status.details;\n        this.metadata = status.metadata;\n    }\n}\nexports.StatusError = StatusError;\n/**\n * Error thrown when we fail to open a channel for the message stream.\n *\n * @class\n *\n * @param {Error} err The original error.\n */\nclass ChannelError extends Error {\n    constructor(err) {\n        super(`Failed to connect to channel. Reason: ${process.env.DEBUG_GRPC ? err.stack : err.message}`);\n        this.code = err.message.includes('deadline')\n            ? google_gax_1.grpc.status.DEADLINE_EXCEEDED\n            : google_gax_1.grpc.status.UNKNOWN;\n        this.details = err.message;\n        this.metadata = new google_gax_1.grpc.Metadata();\n    }\n}\nexports.ChannelError = ChannelError;\n/**\n * @typedef {object} MessageStreamOptions\n * @property {number} [highWaterMark=0] Configures the Buffer level for all\n *     underlying streams. See\n *     {@link https://nodejs.org/en/docs/guides/backpressuring-in-streams/} for\n *     more details.\n * @property {number} [maxStreams=5] Number of streaming connections to make.\n * @property {number} [timeout=300000] Timeout for establishing a connection.\n */\n/**\n * Streaming class used to manage multiple StreamingPull requests.\n *\n * @private\n * @class\n *\n * @param {Subscriber} sub The parent subscriber.\n * @param {MessageStreamOptions} [options] The message stream options.\n */\nclass MessageStream extends stream_1.PassThrough {\n    constructor(sub, options = {}) {\n        options = Object.assign({}, DEFAULT_OPTIONS, options);\n        super({ objectMode: true, highWaterMark: options.highWaterMark });\n        this._options = options;\n        this._retrier = new pull_retry_1.PullRetry();\n        this._streams = new Map();\n        this._subscriber = sub;\n        this._fillStreamPool();\n        this._keepAliveHandle = setInterval(() => this._keepAlive(), KEEP_ALIVE_INTERVAL);\n        this._keepAliveHandle.unref();\n    }\n    /**\n     * Destroys the stream and any underlying streams.\n     *\n     * @param {error?} error An error to emit, if any.\n     * @private\n     */\n    destroy(error) {\n        // We can't assume Node has taken care of this in <14.\n        if (this.destroyed) {\n            return;\n        }\n        super.destroy(error ? error : undefined);\n    }\n    /**\n     * Destroys the stream and any underlying streams.\n     *\n     * @param {error?} error An error to emit, if any.\n     * @param {Function} callback Callback for completion of any destruction.\n     * @private\n     */\n    _destroy(error, callback) {\n        this.destroyed = true;\n        clearInterval(this._keepAliveHandle);\n        for (const stream of this._streams.keys()) {\n            this._removeStream(stream);\n            stream.cancel();\n        }\n        callback(error);\n    }\n    /**\n     * Adds a StreamingPull stream to the combined stream.\n     *\n     * @private\n     *\n     * @param {stream} stream The StreamingPull stream.\n     */\n    _addStream(stream) {\n        this._setHighWaterMark(stream);\n        this._streams.set(stream, false);\n        stream\n            .on('error', err => this._onError(stream, err))\n            .once('status', status => this._onStatus(stream, status))\n            .pipe(this, { end: false });\n    }\n    /**\n     * Attempts to create and cache the desired number of StreamingPull requests.\n     * gRPC does not supply a way to confirm that a stream is connected, so our\n     * best bet is to open the streams and use the client.waitForReady() method to\n     * confirm everything is ok.\n     *\n     * @private\n     *\n     * @returns {Promise}\n     */\n    async _fillStreamPool() {\n        let client;\n        try {\n            client = await this._getClient();\n        }\n        catch (e) {\n            this.destroy(e);\n        }\n        if (this.destroyed) {\n            return;\n        }\n        const deadline = Date.now() + PULL_TIMEOUT;\n        const request = {\n            subscription: this._subscriber.name,\n            streamAckDeadlineSeconds: this._subscriber.ackDeadline,\n            maxOutstandingMessages: this._subscriber.useLegacyFlowControl\n                ? 0\n                : this._subscriber.maxMessages,\n            maxOutstandingBytes: this._subscriber.useLegacyFlowControl\n                ? 0\n                : this._subscriber.maxBytes,\n        };\n        delete this._fillHandle;\n        for (let i = this._streams.size; i < this._options.maxStreams; i++) {\n            const stream = client.streamingPull({ deadline });\n            this._addStream(stream);\n            stream.write(request);\n        }\n        try {\n            await this._waitForClientReady(client);\n        }\n        catch (e) {\n            this.destroy(e);\n        }\n    }\n    /**\n     * It is critical that we keep as few `PullResponse` objects in memory as\n     * possible to reduce the number of potential redeliveries. Because of this we\n     * want to bypass gax for StreamingPull requests to avoid creating a Duplexify\n     * stream, doing so essentially doubles the size of our readable buffer.\n     *\n     * @private\n     *\n     * @returns {Promise.<object>}\n     */\n    async _getClient() {\n        const client = await this._subscriber.getClient();\n        client.initialize();\n        return client.subscriberStub;\n    }\n    /**\n     * Since we do not use the streams to ack/modAck messages, they will close\n     * by themselves unless we periodically send empty messages.\n     *\n     * @private\n     */\n    _keepAlive() {\n        this._streams.forEach((receivedStatus, stream) => {\n            // its possible that a status event fires off (signaling the rpc being\n            // closed) but the stream hasn't drained yet, writing to this stream will\n            // result in a `write after end` error\n            if (!receivedStatus) {\n                stream.write({});\n            }\n        });\n    }\n    /**\n     * Once the stream has nothing left to read, we'll remove it and attempt to\n     * refill our stream pool if needed.\n     *\n     * @private\n     *\n     * @param {Duplex} stream The ended stream.\n     * @param {object} status The stream status.\n     */\n    _onEnd(stream, status) {\n        this._removeStream(stream);\n        if (this._fillHandle) {\n            return;\n        }\n        if (this._retrier.retry(status)) {\n            const delay = this._retrier.createTimeout();\n            this._fillHandle = setTimeout(() => this._fillStreamPool(), delay);\n        }\n        else if (!this._streams.size) {\n            this.destroy(new StatusError(status));\n        }\n    }\n    /**\n     * gRPC will usually emit a status as a ServiceError via `error` event before\n     * it emits the status itself. In order to cut back on emitted errors, we'll\n     * wait a tick on error and ignore it if the status has been received.\n     *\n     * @private\n     *\n     * @param {stream} stream The stream that errored.\n     * @param {Error} err The error.\n     */\n    async _onError(stream, err) {\n        await promisify_1.promisify(setImmediate)();\n        const code = err.code;\n        const receivedStatus = this._streams.get(stream) !== false;\n        if (typeof code !== 'number' || !receivedStatus) {\n            this.emit('error', err);\n        }\n    }\n    /**\n     * gRPC streams will emit a status event once the connection has been\n     * terminated. This is preferable to end/close events because we'll receive\n     * information as to why the stream closed and if it is safe to open another.\n     *\n     * @private\n     *\n     * @param {stream} stream The stream that was closed.\n     * @param {object} status The status message stating why it was closed.\n     */\n    _onStatus(stream, status) {\n        if (this.destroyed) {\n            return;\n        }\n        this._streams.set(stream, true);\n        if (isStreamEnded(stream)) {\n            this._onEnd(stream, status);\n        }\n        else {\n            stream.once('end', () => this._onEnd(stream, status));\n            stream.push(null);\n        }\n    }\n    /**\n     * Removes a stream from the combined stream.\n     *\n     * @private\n     *\n     * @param {stream} stream The stream to remove.\n     */\n    _removeStream(stream) {\n        stream.unpipe(this);\n        this._streams.delete(stream);\n    }\n    /**\n     * Neither gRPC or gax allow for the highWaterMark option to be specified.\n     * However using the default value (16) it is possible to end up with a lot of\n     * PullResponse objects stored in internal buffers. If this were to happen\n     * and the client were slow to process messages, we could potentially see a\n     * very large number of redeliveries happen before the messages even made it\n     * to the client.\n     *\n     * @private\n     *\n     * @param {Duplex} stream The duplex stream to adjust the\n     *     highWaterMarks for.\n     */\n    _setHighWaterMark(stream) {\n        stream._readableState.highWaterMark = this._options.highWaterMark;\n    }\n    /**\n     * Promisified version of gRPCs Client#waitForReady function.\n     *\n     * @private\n     *\n     * @param {object} client The gRPC client to wait for.\n     * @returns {Promise}\n     */\n    async _waitForClientReady(client) {\n        const deadline = Date.now() + this._options.timeout;\n        try {\n            await promisify_1.promisify(client.waitForReady).call(client, deadline);\n        }\n        catch (e) {\n            throw new ChannelError(e);\n        }\n    }\n}\nexports.MessageStream = MessageStream;\n//# sourceMappingURL=message-stream.js.map"]},"metadata":{},"sourceType":"script"}